---
description: Generating Comprehensive UI/UX Plans from Middleware Architecture
globs:
alwaysApply: false
---
# Rule: Generating Comprehensive UI/UX Plans from Middleware Architecture

## Goal

To guide an AI assistant in analyzing existing documents including (but not limited to) PRD, design specs, REST API specs, middleware architecture and creating a comprehensive UI/UX plan that enables Product Managers and Designers to review and ensure high-quality and responsive user interfaces that meet the requirements. The plan serves as the foundation for subsequent task generation and implementation while maintaining Fliplet's branding guidelines and accessibility standards.

## Design Philosophy

**Create beautiful, production-worthy interfaces‚Äînot cookie-cutter designs.**

All UI plans should result in fully-featured, polished webpages ready for production use. Prioritize:

- **Visual Excellence:** Modern, aesthetically pleasing designs with attention to spacing, typography, and visual hierarchy
- **User Delight:** Thoughtful interactions, smooth transitions, and intuitive user flows
- **Production Quality:** Robust error handling, loading states, and edge case coverage
- **Brand Consistency:** Cohesive design language aligned with Fliplet's design principles
- **Accessibility First:** WCAG 2.1 AA compliance built in from the start, not added later

## Output

- **Format:** Markdown (`.md`)
- **Location:** `/tasks/`
- **Filename:** `ui-plan-[project-name].md`
- **Purpose:** Comprehensive UI/UX plan ready for review and task generation

## Important Technical Context

### Vue.js Version

This rule generates UI plans for **Vue.js v3.5.13** projects. All component syntax, lifecycle hooks, and API usage should be compatible with Vue 3.5.13.

### Widget Context

Before generating the UI plan, clarify with the user whether the UI is being built for:
- **Interface Context:** Configuration UI shown in Fliplet Studio (widget settings)
- **Build Context:** Runtime UI shown to end users in the published app

### Essential Documentation References

```yaml
# MUST READ - Include these in your context window

- url: https://api.fliplet.com/v1/widgets/assets
  why: Complete list of available assets (CSS/JS libraries) that widgets can use
  critical: Check available versions, latest version and dependencies before suggesting libraries

- url: https://developers.fliplet.com/Dependencies-and-assets.html
  why: Explains how to properly include assets and manage dependencies in widgets
  section: Focus on "Declaring dependencies" and "Loading assets dynamically"

- url: https://developers.fliplet.com/Introduction.html
  why: Core concepts for building Fliplet widgets (components)
  critical: Understand the widget lifecycle and build/interface contexts

- file: widget.json
  why: Widget configuration file that defines dependencies and settings
  critical: Check existing dependencies before suggesting new ones

- doc: /docs/*-prd.md
  why: Product requirements defining business goals, user journeys, and acceptance criteria
  critical: Align UI behaviours, content hierarchy, and success metrics with the PRD

- doc: /docs/*design-spec*.md
  why: Detailed UI layouts, component behaviours, and interaction nuances
  critical: Ensure the plan reflects prescribed layouts, states, and interaction rules

- doc: /tasks/middleware-plan-[project-name].md
  why: The middleware architecture this UI plan must integrate with
  critical: Understand available services, data flows, and state management
```

## Process

This rule uses a **progressive generation approach** to ensure thorough review at each major UX and design decision point. The plan is generated in three phases, with user approval required between phases.

### Phase 1: User Experience & State Design (UX Foundation)

Generate the user experience design and comprehensive state specifications:

1. **Clarify Context:** Determine if building for interface or build context
2. **Interpret Product & Design Docs:** Absorb PRD and design specifications to understand business goals, target personas, canonical screens, and prescribed interactions
3. **Map User Journeys:** Define complete user flows with entry points, steps, and success criteria
4. **Design State Matrix:** Create comprehensive state-oriented UX specifications for every canonical screen/state
5. **Plan Analytics Strategy:** Define product success metrics, analytics events, and audit logging requirements
6. **Generate Phase 1 Sections:**
   - Overview (with Source Alignment to PRD/design specs)
   - Design Principles
   - User Journey Mapping (all primary and secondary flows)
   - State-Oriented UX Specifications (UI State Matrix, State Transition Matrix)
   - Product Analytics & Audit Logging

**Output:** Present Phase 1 sections to the user with this message:

> "I have generated the user experience design and state specifications for the UI/UX plan. This establishes the complete user journey mapping and state behavior that will guide all interface design.
>
> Please review:
> - User journeys (primary and secondary flows aligned with PRD)
> - State matrix (every canonical state from design specs with entry triggers, allowed actions, transitions)
> - State transitions (interaction matrix showing valid state changes)
> - Analytics strategy (success metrics and event tracking)
>
> **Ready to proceed with visual design and component architecture?** Respond with **'Go'** to continue to Phase 2."

**Wait for user confirmation before proceeding.**

---

### Phase 2: Visual Design & Component Architecture (UI Design)

Once Phase 1 is approved, generate visual design system and component specifications:

6. **Define Technical Stack:** Specify Vue.js version, styling framework (Tailwind CSS), and icon library (lucide-vue-next)
7. **Check Available Assets:** Review Fliplet's asset library for compatible dependencies
8. **Design Component Architecture:** Create reusable component specifications with props, states, and behaviors
9. **Plan Responsive Strategy:** Define breakpoints, layout patterns, and mobile-first adaptations
10. **Plan Theming System:** Design Tailwind configuration with Fliplet brand tokens
11. **Document Accessibility:** Ensure WCAG 2.1 AA compliance throughout all components
12. **Generate Phase 2 Sections:**
   - Technical Stack (Framework, Styling, Icons, Dependencies)
   - Component Architecture (Layout, Page, Form, UI, and Feedback components)
   - Responsive Design Strategy (Breakpoints, Layout Patterns, Tailwind Classes)
   - Theming & Customization (Tailwind Config, Design Tokens, Common Patterns)
   - Interaction Patterns (Forms, Data Loading, Navigation)
   - Accessibility Requirements (WCAG compliance, implementation guidelines, testing)

**Output:** Present Phase 2 sections to the user with this message:

> "I have generated the visual design system and component architecture for the UI/UX plan.
>
> Please review:
> - Technical stack (Vue 3.5.13, Tailwind CSS, lucide-vue-next)
> - Component architecture (all layout, page, form, UI, and feedback components)
> - Responsive design strategy (mobile-first breakpoints and patterns)
> - Theming system (Tailwind config with Fliplet brand colors)
> - Interaction patterns (forms, loading states, navigation)
> - Accessibility requirements (WCAG 2.1 AA compliance)
>
> **Ready to proceed with implementation planning?** Respond with **'Go'** to continue to Phase 3."

**Wait for user confirmation before proceeding.**

---

### Phase 3: Implementation Details & Development Setup (Development Plan)

Once Phase 2 is approved, generate implementation infrastructure and development strategy:

13. **Plan Mock-First Infrastructure:** Design UIConfig, DataService abstraction, MockDataService, fixtures, and test scenarios to enable independent UI development
14. **Plan Middleware Integration:** Define how components integrate with DataService (never directly accessing middleware)
15. **Plan Build Configuration:** Define NPM dependencies, Tailwind/PostCSS setup, Gulp/Webpack build process
16. **Plan Widget File Loading:** Define widget.json configuration and asset loading strategy
17. **Document Module System:** Add Vue dependency injection and ES6 module patterns (if applicable to stack)
18. **Generate Phase 3 Sections:**
   - Mock-First Development Strategy (UIConfig, DataService, MockDataService, fixtures, scenarios, benefits)
   - Integration with Middleware (migration from mock to middleware, state management, event system)
   - Vue Dependency Injection & Module System (if Vue 3 + Babel + Webpack)
   - Implementation Guidelines (Package dependencies, build config, widget file loading)
   - Component Documentation (component template with examples)
   - Testing Strategy (component testing, user testing)
   - QA Test Plan Generation (requirements for generating test plans)
   - File Structure Plan
   - Implementation Priorities (phased rollout)
   - Success Metrics

**Output:** Present Phase 3 sections to the user with this message:

> "I have completed the UI/UX plan with implementation details and development setup.
>
> Phase 3 includes:
> - Mock-first development infrastructure (UIConfig, DataService, fixtures)
> - Middleware integration strategy (progressive from mock ‚Üí hybrid ‚Üí full)
> - Build configuration (NPM packages, Tailwind, Gulp/Webpack)
> - Widget.json setup and asset loading
> - Module system patterns (if applicable to your stack)
> - Complete file structure
> - Testing and QA planning
>
> The complete plan is now ready for review and can be used to generate implementation tasks using `generate-tasks.mdc`."

---

### Progressive Generation Benefits

This phased approach ensures:

‚úÖ **UX Review First:** User journeys and states validated before visual design
‚úÖ **Design System Review:** Visual design and components reviewed before implementation details
‚úÖ **Separation of Concerns:** UX, visual design, and implementation reviewed independently
‚úÖ **Stakeholder-Appropriate:** Product managers review UX, designers review visuals, developers review implementation
‚úÖ **Iterative Refinement:** Early feedback prevents costly rework in later phases
‚úÖ **Mock-First Enabled:** UI can be built and demonstrated independently of middleware
‚úÖ **Flexibility:** User can request changes at each checkpoint before proceeding

## Input Requirements

The AI should analyze the following:

### Product & Design Source Materials
- **Product Requirements:** `/docs/*-prd.md` ‚Äî define business outcomes, user journeys, acceptance criteria
- **Design Specifications:** `/docs/*design-spec*.md` ‚Äî prescribe layouts, state visuals, component hierarchies, interaction rules

### Middleware Documentation
- **Architecture Plan:** `/tasks/middleware-plan-[project-name].md`
- **Implementation Files:** `/src/middleware/` directory structure
- **API Service Interfaces:** Available methods and data structures
- **Workflow Controllers:** User interaction sequences
- **State Management:** Data available for UI display

### Key Analysis Areas
- **User Workflows:** Sequential steps users must complete, aligned with PRD journeys
- **Data Presentation:** Information that needs to be displayed, using design-spec layout guidance
- **User Actions:** Buttons, forms, and interactions required; include locking, validation, and warnings
- **Error States:** How errors should be presented to users, referencing design copy and fallback patterns
- **Loading & Countdown States:** Progressive disclosure, skeleton screens, timers, and lock countdowns
- **Accessibility:** Keyboard navigation, screen reader support, focus management detailed in specs

## UI/UX Plan Structure

The generated plan must follow this exact structure for compatibility with `generate-tasks.mdc` and comprehensive UX review:

```markdown
# UI/UX Plan: [Project Name]

## Overview
[Brief description of the UI system, its purpose, and target users]

### Source Alignment
- **Primary PRD References:** Summarize key feature goals, guardrails, and acceptance criteria informing the UI plan
- **Design Spec References:** Note canonical screen layouts, component patterns, and interaction details guiding the UI

## Technical Stack

### Framework
- **Vue.js Version:** 3.5.13
- **Component API:** Vue Options API (for compatibility)
- **Build Context:** [interface|build] - Specify which context this UI serves

### Styling Framework
- **Tailwind CSS:** Modern utility-first CSS framework
  - Installed via `package.json` as a dev dependency
  - Compiled through Gulp and Webpack build process
  - Configured via `tailwind.config.js`
  - PostCSS processing for production optimization
  - **DO NOT** rely on Fliplet's asset library for Tailwind‚Äîit's compiled into the widget's CSS bundle

### Icon Library
- **lucide-vue-next:** Beautiful, consistent icon set for Vue 3
  - Installed via `package.json`
  - Provides tree-shakeable, customizable SVG icons
  - Use for all icons, logos, and visual indicators
  - **DO NOT** install other icon packages unless absolutely necessary

### Available Fliplet Dependencies
- **fliplet-core:** Core Fliplet functionality (always required)
- **font-awesome:** Available from Fliplet assets (v4.7.0) - use only if lucide-vue-next doesn't have needed icons
- **fliplet-icons:** Fliplet's custom icon font - use only for Fliplet-specific UI elements

### Dependencies to Avoid
- **fliplet-studio-ui:** Not needed when using Tailwind CSS
- **bootstrap-css:** Not needed when using Tailwind CSS
- **Additional UI frameworks:** Tailwind CSS is sufficient for all styling needs

## Design Principles

### Core Principles
- **Responsive Design:** Mobile-first approach with fluid layouts
- **Accessibility:** WCAG 2.1 AA compliance throughout
- **Brand Flexibility:** Customizable theming system
- **User Experience:** Clear navigation and intuitive interactions
- **Performance:** Optimized loading and smooth transitions

### Design System Integration
- **Tailwind CSS Utility Classes:** Use Tailwind's utility-first approach for all styling
- **Custom Components:** Build reusable Vue components with Tailwind classes
- **Design Tokens:** Configure Tailwind's theme to match Fliplet brand colors and spacing
- **Component Variants:** Use Tailwind's @apply directive sparingly for complex, repeated patterns only

## User Journey Mapping

### Primary User Flow: [Flow Name]
**User Goal:** [What the user wants to achieve]
**Entry Point:** [How users access this flow]
**Success Criteria:** [How users know they've succeeded]
**Referenced States:** [Enumerate relevant design-spec states/screens powering this flow]
**PRD Alignment:** [Link behavior back to PRD requirements]

**Steps:**
1. **[Step Name]**
   - User Action: [What the user does]
   - System Response: [How the UI responds; cite design-spec interactions]
   - Data Displayed: [Information shown; reference design layouts]
   - Possible Errors: [Error states and messages; include PRD acceptance criteria]

2. **[Next Step]**
   [Continue for all steps]

### Secondary User Flows
[Document additional user journeys as needed]

## State-Oriented UX Specifications

### UI State Matrix

Use state specifications to clearly outline different states/screens/pages, enabling thorough UX review and comprehensive testing.

> **Instruction:** Enumerate every canonical state captured in the design specification (e.g., dashboards, step-based flows, progress overlays) and ensure each has a corresponding entry below. Where the PRD defines business rules or acceptance criteria for a state, capture those within the relevant fields.

#### State Template

**[State Name]**

- **Entry Triggers:** How do we get here? (events, user actions, preconditions)
- **Design References:** Cite relevant design-spec sections or figures guiding layout/interactions
- **Visibility/Data:** Exactly what's on screen; data freshness rules and loading behavior
- **Allowed Actions:** Available buttons/gestures/menu items; preconditions for each; expected outcomes
- **Forbidden Actions (and Why):** What's disabled/hidden and rationale; how restrictions are communicated
- **System Feedback:** Loading indicators, progress bars, validation messages, toasts, banners (align with design copy)
- **Empty/Error/Offline Variants:** Copy, visuals, retry logic for each edge case; validate against PRD acceptance criteria
- **Permissions/Entitlements:** Role-based access, ownership rules, feature flags
- **Analytics:** Event names, properties, success metrics tracked in this state
- **Transitions:** Which next states are reachable and their triggers

#### Example State Specification

**Dashboard**

- **Entry Triggers:** User navigates to dashboard, page refresh, session timeout recovery
- **Visibility/Data:** Skeleton layout showing page structure, loading spinner in data areas
- **Allowed Actions:** Navigate away via main menu, cancel loading (if applicable)
- **Forbidden Actions (and Why):** No data actions available - buttons disabled with loading states
- **System Feedback:** Progress indicator, "Loading dashboard data..." message
- **Loading/Empty/Error/Offline Variants:** (e.g.)
  - Network error: "Unable to load dashboard. Check connection and try again"
  - Timeout: "Dashboard is taking longer than usual to load. Please wait or refresh"
- **Permissions/Entitlements:** Must have authenticated session and dashboard access role
- **Analytics:** `dashboard_load_started`, `dashboard_load_duration`, `dashboard_load_error`
- **Transitions:** ‚Üí Dashboard Loaded (success), ‚Üí Error State (failure), ‚Üí Login (auth expired)

### State Transition Matrix

Create a matrix (rows = high-level application states, columns = user actions) to identify interaction gaps and valid transitions between major application areas:

> **Instruction:** Use the canonical states extracted from the design specification as matrix rows. Actions should reflect real interactions captured in PRD/design docs (e.g., lock extension, conflict resolution, audit-log access). Highlight restricted transitions mandated by product requirements.

| State / Action | Create New | Edit Existing | Submit | View Details | Delete | Navigate |
|---|---|---|---|---|---|---|
| **Planning Dashboard** | ‚úÖ New Initiative | ‚úÖ Edit Selected | ‚ùå Not Applicable | ‚úÖ View Item | ‚úÖ Archive Item | ‚úÖ All Sections |
| **Work Item Drafting** | ‚úÖ Draft Work Item | ‚úÖ Edit Fields | ‚úÖ Submit for Review | ‚úÖ Preview Draft | ‚ùå Restricted | ‚ö†Ô∏è Confirm Exit |
| **Review & Approval** | ‚ùå Review Only | ‚úÖ Request Changes | ‚úÖ Approve Submission | ‚úÖ View Submission | ‚ùå Restricted | ‚úÖ Back to Dashboard |
| **Deployment Scheduling** | ‚ùå In Progress | ‚úÖ Update Schedule | ‚úÖ Confirm Release | ‚úÖ View Schedule | ‚ùå Restricted | ‚ö†Ô∏è Unsaved Changes |
| **Audit & Reporting** | ‚ùå Read Only | ‚ùå Read Only | ‚ùå Not Applicable | ‚úÖ View History | ‚ùå Restricted | ‚úÖ Back to Dashboard |

## Product Analytics & Audit Logging

Define analytics events and audit logging from a Product perspective to measure success metrics, user behavior, and system usage. This complements engineering's system performance logging.

### Analytics Strategy

#### Product Success Metrics
Document what the Product team considers success for this feature. Reference the PRD to ensure coverage of core KPIs, guardrails, and business outcomes:

- **Primary Success Metrics:** Key performance indicators that define feature success
- **User Engagement Metrics:** How users interact with the feature over time
- **Business Impact Metrics:** Revenue, conversion, or operational efficiency gains
- **User Experience Metrics:** Task completion rates, user satisfaction, error rates

#### Analytics Event Categories

**User Journey Events**
- **Entry Points:** How users discover and access the feature
- **Navigation Events:** Movement through the application workflow
- **Completion Events:** Successful task completion and outcomes
- **Abandonment Events:** Where users drop off and why (include PRD-defined failure thresholds)

**Feature Usage Events**
- **Feature Discovery:** When users find and explore new capabilities
- **Feature Adoption:** First-time usage and ongoing engagement
- **Feature Mastery:** Advanced usage patterns and power user behaviors; align with PRD adoption milestones
- **Feature Feedback:** User satisfaction and feature improvement requests

**Business Process Events**
- **Workflow Initiation:** When business processes start
- **Process Milestones:** Key steps in business workflows
- **Process Completion:** Successful business outcomes
- **Process Optimization:** Efficiency improvements and bottlenecks tied to PRD metrics (e.g., merge duration, conflict resolution rate)

### Analytics Implementation Plan

#### Fliplet App Analytics Events

Use `Fliplet.App.Analytics.event()` for user behavior analytics visible in App Analytics dashboard:

\`\`\`javascript
// Example: Track workflow completion
Fliplet.App.Analytics.event({
  category: 'workflow_console',
  action: 'process_completed',
  label: 'Launch Checklist',
  value: 1 // Optional numeric value
});

// Example: Track feature usage
Fliplet.App.Analytics.event({
  category: 'ui_interaction',
  action: 'button_clicked',
  label: 'Export Summary Report'
});

// Example: Track user journey milestone
Fliplet.App.Analytics.event({
  category: 'process_journey',
  action: 'milestone_reached',
  label: 'First Process Completed'
});
\`\`\`

#### Fliplet App Logs for Audit Trail

Use `Fliplet.App.Logs.create()` for audit logs visible to organization admins:

\`\`\`javascript
// Example: Log data modification (scope only, no detailed values)
Fliplet.App.Logs.create({
  action: 'Record metadata updated',
  entity_id: 'record_123',
  modified_fields: ['title', 'description', 'status'],
  timestamp: new Date().toISOString()
}, 'record.metadata.modified');

// Example: Log sensitive actions
Fliplet.App.Logs.create({
  action: 'Workflow transitioned to Approved',
  entity_id: 'record_123',
  context: 'Operations Review',
  outcome: 'approved',
  timestamp: new Date().toISOString()
}, 'workflow.transition.completed');

// Example: Log permission changes (scope only)
Fliplet.App.Logs.create({
  action: 'User role updated',
  target_user_id: 'user_789',
  entity_scope: 'workspace_123',
  timestamp: new Date().toISOString()
}, 'user.permissions.changed');
\`\`\`

#### User Interaction Analytics

Track actual user interactions and actions using Fliplet Analytics Events:

**User Actions**
\`\`\`javascript
// When user clicks a button
Fliplet.App.Analytics.event({
  category: 'user_action',
  action: 'button_clicked',
  label: 'Submit for Approval'
});

// When user navigates to a section
Fliplet.App.Analytics.event({
  category: 'navigation',
  action: 'section_opened',
  label: 'Review Hub'
});

// When user completes a form
Fliplet.App.Analytics.event({
  category: 'form_interaction',
  action: 'form_submitted',
  label: 'Workflow Intake Form'
});
\`\`\`

**Critical Actions (Analytics + Audit Log)**
\`\`\`javascript
// User performs critical action - track engagement + log for audit
Fliplet.App.Analytics.event({
  category: 'critical_action',
  action: 'workflow_closed',
  label: 'Operations Release',
  value: 1
});

// Log the business outcome for admin review
Fliplet.App.Logs.create({
  action: 'Workflow closed with Release',
  context: 'Operations Release',
  timestamp: new Date().toISOString()
}, 'workflow.closed');
\`\`\`

**System States (Audit Log Only)**
\`\`\`javascript
// System states like errors, loading timeouts should only be logged for admin review
// DO NOT track these as analytics events since they're not user interactions

// Log system errors for troubleshooting
Fliplet.App.Logs.create({
  action: 'Network timeout during workflow update',
  error_type: 'network_timeout',
  timestamp: new Date().toISOString()
}, 'system.error');
\`\`\`

### Audit Logging Requirements

#### Compliance and Security Logging
Events that need to be logged for audit trails and compliance:

- **Data Access Events:** When users view sensitive information
- **Data Modification Events:** When users change system data
- **Permission Changes:** When user roles or access levels change
- **Configuration Changes:** When system settings are modified
- **Export Events:** When data is downloaded or exported
- **Import Events:** When external data is brought into the system

#### Business Process Audit Trail
Important business events that need permanent records:

- **Approval Workflows:** Who approved what and when
- **Financial Transactions:** Any monetary operations or calculations
- **Regulatory Compliance:** Events required for industry regulations
- **Data Retention:** Events related to data lifecycle management

### Analytics Integration with UI Components

#### Component-Level Event Tracking

Each UI component should define its analytics events:

\`\`\`javascript
// Example component analytics integration
const ComponentAnalytics = {
  // Form component events
  FormSubmission: {
    event: 'form_submitted',
    required_properties: ['form_type', 'validation_errors', 'completion_time'],
    success_metric: 'form_completion_rate'
  },

  // Table component events
  DataTableInteraction: {
    event: 'table_action_performed',
    required_properties: ['action_type', 'row_count', 'filter_applied'],
    success_metric: 'data_discoverability'
  },

  // Navigation component events
  NavigationUsage: {
    event: 'navigation_item_clicked',
    required_properties: ['destination', 'source_page', 'user_intent'],
    success_metric: 'navigation_efficiency'
  }
};
\`\`\`

#### User Experience Analytics

Track user experience quality metrics:

- **Task Efficiency:** Time to complete common tasks
- **Error Rates:** Frequency and types of user errors
- **Help Usage:** When users need assistance or documentation
- **Feature Discovery:** How users learn about new capabilities
- **Customization Usage:** How users personalize their experience

### Analytics Success Measurement

#### Key Performance Indicators (KPIs)
- **Feature Adoption Rate:** Percentage of eligible users who use the feature
- **Task Success Rate:** Percentage of successful task completions
- **User Retention Rate:** Users who return to use the feature repeatedly
- **Time to Value:** How quickly users achieve their goals
- **User Satisfaction Score:** Direct feedback from users about the experience

#### Reporting and Dashboards
- **Real-time Monitoring:** Live dashboard for critical metrics
- **Weekly Business Reviews:** Summary reports for stakeholders
- **Monthly Deep Dives:** Detailed analysis of user behavior patterns
- **Quarterly Strategy Reviews:** Long-term trend analysis and planning

### Privacy and Data Protection

#### Data Collection Guidelines
- **Minimal Data Principle:** Only collect data necessary for defined success metrics
- **User Consent:** Clear communication about what data is collected and why
- **Data Anonymization:** Remove personally identifiable information where possible
- **Retention Policies:** Define how long analytics data is stored

#### GDPR and Privacy Compliance
- **Right to Delete:** Ability to remove user data from analytics systems
- **Data Portability:** Export user's analytics data in readable format
- **Consent Management:** Track and manage user consent for different data types
- **Privacy by Design:** Build privacy considerations into analytics architecture

## Component Architecture

### Layout Components

#### AppShell
**Purpose:** Main application wrapper providing consistent structure
**Features:**
- Responsive navigation
- Branding area
- Content container
- Footer information

**Props:**
\`\`\`javascript
{
  branding: Object,     // Logo, colors, typography
  navigation: Array,    // Menu items and structure
  user: Object,        // Current user information
  showFooter: Boolean  // Toggle footer visibility
}
\`\`\`

#### NavigationHeader
**Purpose:** Primary navigation and branding display
**Responsive Behavior:**
- Desktop: Horizontal navigation bar
- Tablet: Condensed navigation
- Mobile: Hamburger menu with slide-out drawer
- **Design References:** [Map to design spec sections defining header layout, progress indicators, lock warnings]
- **PRD Alignment:** [Summarize responsibilities tied to product requirements]

### Page Components

#### [PageName]View (Map to design-spec page/state names)
**Purpose:** [What this page displays and manages]
**Design References:** [Call out the design-spec section that defines layout, components, warnings]
**PRD Alignment:** [Tie page responsibilities back to product requirements]
**Data Requirements:** [What middleware data it consumes]
**User Actions:** [Primary interactions available]
**States:**
- Loading: [How loading is indicated; include skeleton/timer guidance from design]
- Empty: [What shows when no data; cite design copy]
- Error: [How errors are displayed; include PRD acceptance messaging]
- Success: [Success state appearance]

### Form Components

#### [FormName]Form
**Purpose:** [What data this form collects]
**Design References:** [Specify design-spec section showing field arrangement, helper text, validation]
**Fields:** [List all form fields with types]
**Validation:** [Client-side validation rules; incorporate PRD acceptance criteria and design error messaging]
**Submission:** [How form interacts with middleware]

### UI Components

#### DataTable (Reference design-spec tab/table patterns)
**Purpose:** Display tabular data with sorting and filtering
**Design References:** [Tie back to table layouts, column configurations, and nested interactions described in design spec]
**Features:**
- Responsive table design
- Column sorting
- Search/filter functionality
- Pagination
- Row actions
- Nested rows / association indicators (if specified)
- Selection/locking indicators (if applicable in design spec)

#### StatusIndicator
**Purpose:** Show workflow progress and status
**States:** [Different status types and their visual representation]

#### ActionButton
**Purpose:** Primary action triggers with loading states
**Variants:** Primary, Secondary, Danger, Success

### Feedback Components

#### NotificationToast
**Purpose:** Temporary feedback messages
**Types:** Success, Warning, Error, Info
**Behavior:** Auto-dismiss with manual close option
- **Design References:** [Link to design-spec messaging patterns and copy]
- **PRD Alignment:** [Ensure warnings/success align with product acceptance criteria]

#### ModalDialog
**Purpose:** Confirmations and focused interactions
**Variants:** Confirm, Alert, Custom content
- **Design References:** [Specify modal layouts and content flows from design spec]
- **PRD Alignment:** [Tie usage to business rules requiring confirmation]

## Responsive Design Strategy

### Breakpoints
\`\`\`scss
$breakpoints: (
  'mobile': 320px,    // Base mobile design
  'tablet': 768px,    // Tablet portrait
  'desktop': 1024px,  // Desktop and larger
  'wide': 1440px     // Wide screens
);
\`\`\`

### Layout Patterns

#### Mobile First
- Single column layouts
- Stacked navigation
- Full-width forms
- Collapsed tables to cards

#### Tablet Adaptations
- Two-column layouts where appropriate
- Side navigation option
- Expanded table views
- Modal dialogs instead of full-screen

#### Desktop Enhancements
- Multi-column dashboards
- Persistent navigation
- Side-by-side comparisons
- Advanced filtering panels

### Tailwind Responsive Classes

Use Tailwind's responsive prefixes for all breakpoint-specific styling:

\`\`\`vue
<template>
  <!-- Mobile-first: stack vertically, then side-by-side on tablet+ -->
  <div class="flex flex-col md:flex-row gap-4">
    <!-- Content -->
  </div>

  <!-- Hide on mobile, show on desktop -->
  <nav class="hidden lg:block">
    <!-- Desktop navigation -->
  </nav>

  <!-- Show on mobile, hide on desktop -->
  <button class="lg:hidden">
    <!-- Mobile menu button -->
  </button>

  <!-- Responsive padding and text sizes -->
  <div class="px-4 md:px-6 lg:px-8">
    <h1 class="text-xl md:text-2xl lg:text-3xl">
      Responsive Heading
    </h1>
  </div>
</template>
\`\`\`

**Breakpoint Mapping:**
- Default: Mobile (0px+) - no prefix
- `sm:`: 640px and up
- `md:`: 768px and up (tablet)
- `lg:`: 1024px and up (desktop)
- `xl:`: 1280px and up (wide desktop)

## Theming & Customization

### Tailwind Configuration
Configure Tailwind theme in `tailwind.config.js` to match Fliplet branding:

\`\`\`javascript
// tailwind.config.js
module.exports = {
  content: [
    './src/**/*.{vue,js,html}',
    './build.html'
  ],
  theme: {
    extend: {
      colors: {
        // Fliplet Brand Colors
        primary: {
          DEFAULT: '#00abd1',
          50: '#e6f7fb',
          100: '#b3e7f4',
          500: '#00abd1',
          600: '#0095b8',
          700: '#00809f',
        },
        secondary: {
          DEFAULT: '#eae9ec',
          50: '#fafafa',
          100: '#eae9ec',
          500: '#d4d3d8',
          700: '#a8a7af',
        },
        accent: {
          DEFAULT: '#36344c',
          500: '#36344c',
          700: '#242333',
        },
        // Semantic Colors
        success: '#19cd9d',
        warning: '#ed9119',
        error: '#e03629',
        info: '#413e5b',
      },
      fontFamily: {
        sans: ['Open Sans', 'Helvetica Neue', 'Helvetica', 'Arial', 'sans-serif'],
      },
      fontSize: {
        base: '14px',
      },
      spacing: {
        // 8px base spacing unit
        unit: '8px',
      },
      maxWidth: {
        container: '1200px',
      },
      boxShadow: {
        sm: '0 1px 3px rgba(0, 0, 0, 0.12)',
        md: '0 4px 6px rgba(0, 0, 0, 0.1)',
        lg: '0 10px 15px rgba(0, 0, 0, 0.1)',
      },
      borderRadius: {
        DEFAULT: '4px',
      },
    },
  },
  plugins: [
    require('@tailwindcss/forms'),
    require('@tailwindcss/typography'),
  ],
};
\`\`\`

### Using Tailwind Design Tokens

Apply Tailwind classes using the configured theme:

\`\`\`vue
<template>
  <!-- Primary button using brand colors -->
  <button class="bg-primary hover:bg-primary-600 text-white px-4 py-2 rounded">
    Click Me
  </button>

  <!-- Success state -->
  <div class="bg-success/10 border border-success text-success-700 px-4 py-3 rounded">
    Success message
  </div>

  <!-- Card with shadow -->
  <div class="bg-white shadow-md rounded p-6 max-w-container mx-auto">
    Card content
  </div>
</template>
\`\`\`

### Custom Component Classes

For complex, repeated patterns, use `@apply` in component styles:

\`\`\`vue
<style scoped>
.btn-primary {
  @apply bg-primary hover:bg-primary-600 text-white font-medium py-2 px-4 rounded transition-colors;
}

.card {
  @apply bg-white shadow-md rounded-lg p-6 border border-gray-200;
}
</style>
\`\`\`

### Common Tailwind Patterns for Beautiful UIs

#### Buttons
\`\`\`vue
<!-- Primary Button -->
<button class="bg-primary hover:bg-primary-600 active:bg-primary-700 text-white font-medium py-2 px-4 rounded-lg transition-colors shadow-sm hover:shadow-md">
  Primary Action
</button>

<!-- Secondary Button -->
<button class="bg-white hover:bg-gray-50 text-gray-700 font-medium py-2 px-4 rounded-lg border border-gray-300 transition-colors">
  Secondary Action
</button>

<!-- Danger Button -->
<button class="bg-error hover:bg-red-700 text-white font-medium py-2 px-4 rounded-lg transition-colors">
  Delete
</button>

<!-- Icon Button -->
<button class="p-2 hover:bg-gray-100 rounded-lg transition-colors">
  <Settings class="w-5 h-5 text-gray-600" />
</button>
\`\`\`

#### Cards and Containers
\`\`\`vue
<!-- Basic Card -->
<div class="bg-white rounded-lg shadow-md p-6 border border-gray-200">
  <h3 class="text-lg font-semibold text-gray-900 mb-2">Card Title</h3>
  <p class="text-gray-600">Card content goes here</p>
</div>

<!-- Interactive Card (hover effect) -->
<div class="bg-white rounded-lg shadow-md p-6 border border-gray-200 hover:shadow-lg hover:border-primary transition-all cursor-pointer">
  <h3 class="text-lg font-semibold text-gray-900 mb-2">Interactive Card</h3>
</div>

<!-- Card with Header and Footer -->
<div class="bg-white rounded-lg shadow-md overflow-hidden border border-gray-200">
  <div class="bg-gray-50 px-6 py-4 border-b border-gray-200">
    <h3 class="text-lg font-semibold text-gray-900">Header</h3>
  </div>
  <div class="p-6">
    <p class="text-gray-600">Content</p>
  </div>
  <div class="bg-gray-50 px-6 py-4 border-t border-gray-200 flex justify-end gap-3">
    <button class="px-4 py-2 text-gray-700 hover:bg-gray-200 rounded transition-colors">Cancel</button>
    <button class="px-4 py-2 bg-primary text-white rounded hover:bg-primary-600 transition-colors">Save</button>
  </div>
</div>
\`\`\`

#### Form Inputs
\`\`\`vue
<!-- Text Input -->
<input
  type="text"
  class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary focus:border-primary outline-none transition-all"
  placeholder="Enter text..."
/>

<!-- Input with Icon -->
<div class="relative">
  <Search class="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-400" />
  <input
    type="text"
    class="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary focus:border-primary outline-none"
    placeholder="Search..."
  />
</div>

<!-- Input with Error State -->
<div>
  <input
    type="email"
    class="w-full px-4 py-2 border border-error rounded-lg focus:ring-2 focus:ring-error outline-none"
    placeholder="Email"
  />
  <p class="mt-1 text-sm text-error">Please enter a valid email address</p>
</div>

<!-- Select Dropdown -->
<select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary focus:border-primary outline-none bg-white">
  <option>Select an option</option>
  <option>Option 1</option>
  <option>Option 2</option>
</select>
\`\`\`

#### Alerts and Notifications
\`\`\`vue
<!-- Success Alert -->
<div class="bg-success/10 border border-success rounded-lg p-4 flex items-start gap-3">
  <CheckCircle2 class="w-5 h-5 text-success flex-shrink-0 mt-0.5" />
  <div>
    <h4 class="font-semibold text-success-700 mb-1">Success!</h4>
    <p class="text-sm text-success-700">Your changes have been saved successfully.</p>
  </div>
</div>

<!-- Error Alert -->
<div class="bg-error/10 border border-error rounded-lg p-4 flex items-start gap-3">
  <AlertCircle class="w-5 h-5 text-error flex-shrink-0 mt-0.5" />
  <div>
    <h4 class="font-semibold text-red-900 mb-1">Error</h4>
    <p class="text-sm text-red-800">Something went wrong. Please try again.</p>
  </div>
</div>

<!-- Warning Alert -->
<div class="bg-warning/10 border border-warning rounded-lg p-4 flex items-start gap-3">
  <AlertTriangle class="w-5 h-5 text-warning flex-shrink-0 mt-0.5" />
  <div>
    <h4 class="font-semibold text-orange-900 mb-1">Warning</h4>
    <p class="text-sm text-orange-800">This action cannot be undone.</p>
  </div>
</div>

<!-- Info Alert -->
<div class="bg-info/10 border border-info rounded-lg p-4 flex items-start gap-3">
  <Info class="w-5 h-5 text-info flex-shrink-0 mt-0.5" />
  <div>
    <h4 class="font-semibold text-indigo-900 mb-1">Information</h4>
    <p class="text-sm text-indigo-800">Here's some helpful information.</p>
  </div>
</div>
\`\`\`

#### Loading States
\`\`\`vue
<!-- Loading Spinner -->
<div class="flex items-center justify-center p-8">
  <Loader2 class="w-8 h-8 text-primary animate-spin" />
</div>

<!-- Skeleton Loader -->
<div class="animate-pulse">
  <div class="h-4 bg-gray-200 rounded w-3/4 mb-4"></div>
  <div class="h-4 bg-gray-200 rounded w-1/2 mb-4"></div>
  <div class="h-4 bg-gray-200 rounded w-5/6"></div>
</div>

<!-- Button Loading State -->
<button
  disabled
  class="bg-primary text-white font-medium py-2 px-4 rounded-lg opacity-50 cursor-not-allowed inline-flex items-center gap-2"
>
  <Loader2 class="w-4 h-4 animate-spin" />
  <span>Loading...</span>
</button>
\`\`\`

#### Badges and Tags
\`\`\`vue
<!-- Status Badges -->
<span class="inline-flex items-center gap-1 px-2.5 py-0.5 rounded-full text-xs font-medium bg-success/10 text-success border border-success">
  <CheckCircle2 class="w-3 h-3" />
  Active
</span>

<span class="inline-flex items-center gap-1 px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-700 border border-gray-300">
  <Clock class="w-3 h-3" />
  Pending
</span>

<span class="inline-flex items-center gap-1 px-2.5 py-0.5 rounded-full text-xs font-medium bg-error/10 text-error border border-error">
  <X class="w-3 h-3" />
  Inactive
</span>
\`\`\`

## Interaction Patterns

### Form Interactions
- **Inline Validation:** Real-time feedback as users type (reference design-spec copy for validation messaging)
- **Error Prevention:** Disable submit until valid, following PRD acceptance criteria
- **Clear Error Messages:** Specific, actionable error text consistent with design content guidelines
- **Progress Indication:** Multi-step form progress, aligned with design-spec progress indicators and PRD flow sequencing

### Data Loading
- **Skeleton Screens:** Show layout structure while loading; follow design-spec visuals and timing guidance
- **Progressive Loading:** Load critical content first per PRD priorities
- **Optimistic Updates:** Immediate UI feedback when actions succeed; match design-spec animations
- **Error Recovery:** Clear retry mechanisms using prescribed copy and button placements

### Navigation
- **Breadcrumbs:** Clear location indication matching design hierarchy
- **Tab Navigation:** For related content sections; replicate tab behaviour defined in design spec
- **Pagination:** For large data sets, using design-spec controls and PRD limits
- **Search:** Global and contextual search; include filtering rules and debounce requirements from PRD

## Accessibility Requirements

### WCAG 2.1 AA Compliance
- **Color Contrast:** Minimum 4.5:1 for normal text, 3:1 for large text
- **Keyboard Navigation:** All interactive elements keyboard accessible
- **Focus Indicators:** Clear visual focus states
- **Screen Reader Support:** Proper ARIA labels and landmarks

### Implementation Guidelines
\`\`\`vue
<!-- Example accessible component structure -->
<template>
  <nav role="navigation" aria-label="Main navigation">
    <ul role="list">
      <li v-for="item in navItems" :key="item.id">
        <a
          :href="item.url"
          :aria-current="item.active ? 'page' : null"
          @click="handleNavigation"
        >
          {{ item.label }}
        </a>
      </li>
    </ul>
  </nav>
</template>
\`\`\`

### Testing Requirements
- **Keyboard Testing:** Navigate entire app without mouse
- **Screen Reader Testing:** NVDA/JAWS on Windows, VoiceOver on Mac
- **Color Contrast:** Automated testing with axe-core
- **Focus Management:** Proper focus restoration after modals

## Performance Optimization

### Loading Strategy
- **Code Splitting:** Lazy load route components
- **Image Optimization:** Responsive images with loading="lazy"
- **Font Loading:** FOUT prevention with font-display
- **CSS Optimization:** Critical CSS inline, rest async

### Runtime Performance
- **Virtual Scrolling:** For large lists
- **Debounced Inputs:** Prevent excessive API calls
- **Memoization:** Cache expensive computations
- **Animation Performance:** CSS transforms over position

## Error Handling & Feedback

### Error States
- **Network Errors:** Clear offline indication
- **Validation Errors:** Inline field-level messages
- **System Errors:** User-friendly error pages
- **Permission Errors:** Clear access denied messaging

### User Feedback
- **Success Confirmations:** Clear success messages
- **Progress Indicators:** Long-running operations
- **Undo Actions:** Where appropriate
- **Help Text:** Contextual assistance

## Mock-First Development Strategy

### Philosophy

**UI development should never be blocked by middleware availability.**

- **Independent Development**: UI can be built, tested, and iterated without middleware
- **Progressive Integration**: Start with mocks, swap to middleware when ready
- **Design Review Enablement**: Stakeholders see working UI without functional backend
- **Parallel Development**: UI and middleware teams work simultaneously
- **Rapid Prototyping**: Iterate on UI design without backend concerns
- **Realistic Testing**: Test with comprehensive mock scenarios including errors and edge cases

### Configuration-Based Mode Switching

Use a simple configuration object to control data source:

\`\`\`javascript
// src/config/ui-config.js
const UIConfig = {
  // Development mode: 'mock' | 'middleware' | 'hybrid'
  mode: 'mock',

  // Mock behavior settings
  mock: {
    delay: 500,           // Simulate network latency (ms)
    errorRate: 0.1,       // 10% random error rate for testing
    enableErrors: true,   // Show error scenarios
    logRequests: true     // Console log all data requests
  },

  // Toggle modes easily during development
  useMockData: function() {
    this.mode = 'mock';
    console.log('üì¶ Using mock data');
  },

  useMiddleware: function() {
    this.mode = 'middleware';
    console.log('‚ö° Using middleware');
  },

  useHybrid: function(mockServices = []) {
    this.mode = 'hybrid';
    this.hybridMockServices = mockServices;
    console.log('üîÄ Using hybrid mode:', mockServices);
  }
};

// Export for use in components
window.UIConfig = UIConfig;

// Quick toggle in browser console:
// UIConfig.useMockData()
// UIConfig.useMiddleware()
\`\`\`

### Data Service Abstraction Layer

Create a single interface for all data operations that switches between mock and real implementation:

\`\`\`javascript
// src/services/DataService.js

/**
 * Data Service Abstraction Layer
 * Provides unified interface for data operations with configurable backend
 */
class DataService {
  constructor() {
    this.config = window.UIConfig;
    this.mockService = new MockDataService();
    this.middlewareService = window.[WidgetName]?.middleware;
  }

  /**
   * Get current mode from config
   */
  get mode() {
    return this.config.mode;
  }

  /**
   * Check if service should use mock data
   */
  shouldUseMock(serviceName) {
    if (this.mode === 'mock') return true;
    if (this.mode === 'middleware') return false;
    if (this.mode === 'hybrid') {
      return this.config.hybridMockServices?.includes(serviceName);
    }
    return false;
  }

  /**
   * Get workflow state with automatic mode switching
   */
  async getWorkflowState(workflowName) {
    if (this.shouldUseMock('workflow')) {
      return this.mockService.getWorkflowState(workflowName);
    }

    if (!this.middlewareService) {
      console.warn('Middleware not available, falling back to mock data');
      return this.mockService.getWorkflowState(workflowName);
    }

    return this.middlewareService.stateManager.getWorkflowState(workflowName);
  }

  /**
   * Submit form data
   */
  async submitData(data) {
    if (this.shouldUseMock('submit')) {
      return this.mockService.submitData(data);
    }

    return this.middlewareService.apiService.submit(data);
  }

  /**
   * Fetch list data
   */
  async fetchItems(filters = {}) {
    if (this.shouldUseMock('items')) {
      return this.mockService.fetchItems(filters);
    }

    return this.middlewareService.apiService.fetchItems(filters);
  }

  /**
   * Subscribe to state changes
   */
  on(eventName, callback) {
    if (this.shouldUseMock('events')) {
      return this.mockService.on(eventName, callback);
    }

    return this.middlewareService.on(eventName, callback);
  }

  /**
   * Unsubscribe from state changes
   */
  off(eventName, callback) {
    if (this.shouldUseMock('events')) {
      return this.mockService.off(eventName, callback);
    }

    return this.middlewareService.off(eventName, callback);
  }
}

// Create singleton instance
window.DataService = new DataService();
\`\`\`

### Mock Data Infrastructure

Comprehensive mock data service with realistic behavior:

\`\`\`javascript
// src/mocks/MockDataService.js

/**
 * Mock Data Service
 * Provides realistic mock data and behavior for UI development
 */
class MockDataService {
  constructor() {
    this.config = window.UIConfig;
    this.fixtures = MockFixtures;
    this.eventListeners = {};
  }

  /**
   * Simulate network delay
   */
  async delay() {
    const ms = this.config.mock.delay || 500;
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Simulate random errors for testing
   */
  shouldSimulateError() {
    if (!this.config.mock.enableErrors) return false;
    return Math.random() < (this.config.mock.errorRate || 0);
  }

  /**
   * Log mock request
   */
  log(method, ...args) {
    if (this.config.mock.logRequests) {
      console.log(\`üì¶ Mock: \${method}\`, ...args);
    }
  }

  /**
   * Get workflow state
   */
  async getWorkflowState(workflowName) {
    this.log('getWorkflowState', workflowName);
    await this.delay();

    if (this.shouldSimulateError()) {
      throw new Error('Simulated network error');
    }

    return this.fixtures.workflowStates[workflowName] || null;
  }

  /**
   * Submit data
   */
  async submitData(data) {
    this.log('submitData', data);
    await this.delay();

    if (this.shouldSimulateError()) {
      throw new Error('Submission failed: Simulated error');
    }

    return {
      success: true,
      id: 'mock-' + Date.now(),
      data: data
    };
  }

  /**
   * Fetch items with filtering
   */
  async fetchItems(filters = {}) {
    this.log('fetchItems', filters);
    await this.delay();

    if (this.shouldSimulateError()) {
      throw new Error('Failed to fetch items');
    }

    let items = [...this.fixtures.items];

    // Apply filters
    if (filters.status) {
      items = items.filter(item => item.status === filters.status);
    }

    if (filters.search) {
      items = items.filter(item =>
        item.name.toLowerCase().includes(filters.search.toLowerCase())
      );
    }

    return {
      items,
      total: items.length,
      page: filters.page || 1
    };
  }

  /**
   * Event system for mock state changes
   */
  on(eventName, callback) {
    if (!this.eventListeners[eventName]) {
      this.eventListeners[eventName] = [];
    }
    this.eventListeners[eventName].push(callback);
  }

  off(eventName, callback) {
    if (!this.eventListeners[eventName]) return;
    this.eventListeners[eventName] = this.eventListeners[eventName]
      .filter(cb => cb !== callback);
  }

  emit(eventName, data) {
    if (!this.eventListeners[eventName]) return;
    this.eventListeners[eventName].forEach(callback => callback(data));
  }
}
\`\`\`

### Mock Data Fixtures

Comprehensive test data covering all scenarios:

\`\`\`javascript
// src/mocks/fixtures.js

const MockFixtures = {
  /**
   * Workflow states for different scenarios
   */
  workflowStates: {
    publishing: {
      currentStep: 'initialize',
      progress: 0.2,
      data: {
        platform: 'ios',
        type: 'appStore',
        teamId: 'AFIG8RX79F'
      },
      errors: [],
      isComplete: false,
      dependencies: []
    },

    'publishing-error': {
      currentStep: 'upload',
      progress: 0.6,
      data: {},
      errors: [{
        code: 'UPLOAD_FAILED',
        message: 'Build upload failed. Please try again.'
      }],
      isComplete: false,
      dependencies: ['initialize']
    },

    'publishing-complete': {
      currentStep: 'complete',
      progress: 1.0,
      data: {
        submissionId: 'sub_12345',
        status: 'published'
      },
      errors: [],
      isComplete: true,
      dependencies: ['initialize', 'configure', 'upload']
    }
  },

  /**
   * List items for tables/grids
   */
  items: [
    {
      id: '1',
      name: 'Production App',
      status: 'published',
      lastModified: '2024-01-15T10:30:00Z',
      owner: 'John Smith'
    },
    {
      id: '2',
      name: 'Staging App',
      status: 'draft',
      lastModified: '2024-01-14T15:45:00Z',
      owner: 'Jane Doe'
    },
    {
      id: '3',
      name: 'Dev App',
      status: 'in-progress',
      lastModified: '2024-01-13T09:20:00Z',
      owner: 'Bob Wilson'
    }
  ],

  /**
   * User data
   */
  currentUser: {
    id: 'user_123',
    name: 'Demo User',
    email: 'demo@example.com',
    role: 'admin',
    permissions: ['read', 'write', 'delete']
  },

  /**
   * Error scenarios for testing
   */
  errors: {
    network: new Error('Network request failed'),
    validation: new Error('Validation failed: Invalid input'),
    permission: new Error('Permission denied'),
    notFound: new Error('Resource not found')
  },

  /**
   * Empty state data
   */
  emptyStates: {
    noItems: {
      items: [],
      total: 0,
      message: 'No items found'
    },
    noResults: {
      items: [],
      total: 0,
      message: 'No results match your search'
    }
  }
};

window.MockFixtures = MockFixtures;
\`\`\`

### Component Implementation Pattern

Components use DataService abstraction - never directly access middleware:

\`\`\`vue
<template>
  <div class="workflow-container">
    <!-- Loading State -->
    <div v-if="loading" class="flex items-center justify-center p-8">
      <Loader2 class="w-8 h-8 text-primary animate-spin" />
      <span class="ml-3">Loading workflow state...</span>
    </div>

    <!-- Error State -->
    <div v-else-if="error" class="bg-error/10 border border-error rounded-lg p-4">
      <AlertCircle class="w-5 h-5 text-error inline-block mr-2" />
      <span class="text-error">{{ error }}</span>
      <button @click="retry" class="ml-4 text-error underline">Retry</button>
    </div>

    <!-- Success State -->
    <div v-else-if="workflowState">
      <h2>{{ workflowState.currentStep }}</h2>
      <div class="progress-bar">
        <div class="progress-fill" :style="{ width: (workflowState.progress * 100) + '%' }"></div>
      </div>
    </div>
  </div>
</template>

<script>
import { Loader2, AlertCircle } from 'lucide-vue-next';

/**
 * WorkflowView Component
 * Displays workflow state using DataService abstraction
 * Works with both mock data and real middleware
 */
export default {
  name: 'WorkflowView',

  components: {
    Loader2,
    AlertCircle
  },

  props: {
    workflowName: {
      type: String,
      required: true
    }
  },

  data() {
    return {
      dataService: window.DataService, // Use abstraction layer
      workflowState: null,
      loading: false,
      error: null
    };
  },

  async created() {
    await this.loadWorkflowState();
    this.subscribeToUpdates();
  },

  methods: {
    async loadWorkflowState() {
      this.loading = true;
      this.error = null;

      try {
        // DataService automatically uses mock or middleware based on UIConfig
        this.workflowState = await this.dataService.getWorkflowState(this.workflowName);
      } catch (err) {
        this.error = err.message;
        console.error('Failed to load workflow state:', err);
      } finally {
        this.loading = false;
      }
    },

    async retry() {
      await this.loadWorkflowState();
    },

    subscribeToUpdates() {
      // Event subscription also uses abstraction
      this.dataService.on('workflow:updated', this.handleWorkflowUpdate);
    },

    handleWorkflowUpdate(data) {
      if (data.workflowName === this.workflowName) {
        this.workflowState = data.state;
      }
    }
  },

  beforeUnmount() {
    // Cleanup
    this.dataService.off('workflow:updated', this.handleWorkflowUpdate);
  }
};
</script>
\`\`\`

### Development Mode Toggle

Easy switching between modes during development:

\`\`\`javascript
// In browser console or during development:

// Use mock data (default for UI development)
UIConfig.useMockData();

// Use real middleware (when middleware is ready)
UIConfig.useMiddleware();

// Use hybrid mode (some services mock, some real)
UIConfig.useHybrid(['workflow', 'items']); // Mock only these services

// Adjust mock behavior
UIConfig.mock.delay = 1000;        // Slower network
UIConfig.mock.errorRate = 0.5;     // 50% error rate for stress testing
UIConfig.mock.enableErrors = false; // Disable random errors
\`\`\`

### Testing with Mock Scenarios

Test all UI states using mock data:

\`\`\`javascript
// src/mocks/scenarios.js

const TestScenarios = {
  /**
   * Simulate successful workflow completion
   */
  async simulateSuccess() {
    UIConfig.useMockData();
    UIConfig.mock.enableErrors = false;
    console.log('‚úÖ Testing success scenario');
  },

  /**
   * Simulate network errors
   */
  async simulateNetworkError() {
    UIConfig.useMockData();
    UIConfig.mock.errorRate = 1.0; // 100% errors
    UIConfig.mock.enableErrors = true;
    console.log('‚ùå Testing error scenario');
  },

  /**
   * Simulate slow network
   */
  async simulateSlowNetwork() {
    UIConfig.useMockData();
    UIConfig.mock.delay = 3000; // 3 second delay
    console.log('üêå Testing slow network');
  },

  /**
   * Simulate empty states
   */
  async simulateEmptyState() {
    UIConfig.useMockData();
    MockFixtures.items = [];
    console.log('üì≠ Testing empty state');
  },

  /**
   * Reset to normal
   */
  async reset() {
    UIConfig.useMockData();
    UIConfig.mock.delay = 500;
    UIConfig.mock.errorRate = 0.1;
    UIConfig.mock.enableErrors = true;
    console.log('üîÑ Reset to normal mock behavior');
  }
};

window.TestScenarios = TestScenarios;

// Usage in browser console:
// TestScenarios.simulateNetworkError()
// TestScenarios.simulateSlowNetwork()
// TestScenarios.reset()
\`\`\`

### Benefits of Mock-First Approach

‚úÖ **Parallel Development**
- UI team doesn't wait for middleware completion
- Both teams work simultaneously without blocking

‚úÖ **Rapid Prototyping**
- Iterate on UI design quickly
- Get stakeholder feedback early
- No dependency on backend functionality

‚úÖ **Comprehensive Testing**
- Test all UI states (success, error, loading, empty)
- Simulate network conditions (slow, offline, timeout)
- Test edge cases without breaking real data

‚úÖ **Design Reviews**
- Show working UI to stakeholders immediately
- Realistic demos with comprehensive data
- Interactive prototypes without backend

‚úÖ **Progressive Integration**
- Start with 100% mock
- Gradually swap to middleware as it becomes available
- Use hybrid mode to test integration incrementally

‚úÖ **Better Component Isolation**
- Components never directly coupled to middleware
- Easy to test in isolation
- Reusable across projects

‚úÖ **Debugging & Development**
- Toggle between mock and real data easily
- Test error scenarios on demand
- Inspect and modify mock data in browser console

## Integration with Middleware

### Migration from Mock to Middleware

When middleware is ready, integration is seamless:

\`\`\`javascript
// Phase 1: Pure mock development
UIConfig.useMockData();

// Phase 2: Test with real middleware (one service at a time)
UIConfig.useHybrid(['items']); // Use real items, mock everything else

// Phase 3: Full middleware integration
UIConfig.useMiddleware();

// Phase 4: Production - middleware only
UIConfig.mode = 'middleware';
\`\`\`

### State Management Integration

\`\`\`javascript
// Components use DataService - works with both mock and middleware
export default {
  data() {
    return {
      dataService: window.DataService,
      workflowState: null,
      loading: false,
      error: null
    };
  },

  async created() {
    try {
      this.loading = true;
      // Automatically uses mock or middleware based on UIConfig
      this.workflowState = await this.dataService.getWorkflowState('workflow-name');
    } catch (error) {
      this.error = error.message;
    } finally {
      this.loading = false;
    }
  }
};
\`\`\`

### Event System Integration

\`\`\`javascript
// Event subscription works the same for mock and middleware
mounted() {
  this.dataService.on('workflow:updated', this.handleWorkflowUpdate);
  this.dataService.on('error:occurred', this.handleError);
},

beforeUnmount() {
  this.dataService.off('workflow:updated', this.handleWorkflowUpdate);
  this.dataService.off('error:occurred', this.handleError);
}
\`\`\`

## Vue Dependency Injection & Module System

**APPLICABILITY:** These guidelines apply only to projects using **Vue 3.x with ES6 modules and a build system (Webpack/Babel)**. If your project uses a different framework, build tool, or no build system at all, skip this section.

### Vue 3 Dependency Injection Pattern

**CRITICAL (Vue 3 projects only):** Always use Vue's `provide`/`inject` pattern for middleware access. Never rely on global variables.

#### Why Dependency Injection?

‚ùå **Problems with Global Variables:**
- Race conditions when components mount before middleware initializes
- Timing issues with `window.FlipletAppMerge.middleware` availability
- No guarantee middleware exists when components need it
- Difficult to test components in isolation

‚úÖ **Benefits of Dependency Injection:**
- Middleware guaranteed to be available when components mount
- Clean separation of concerns
- Easy to mock for testing
- No timing issues or race conditions
- Vue lifecycle manages dependencies correctly

#### Implementation Pattern

**Step 1: Initialize and Provide Middleware (main.js)**

```javascript
// src/main.js
import { createApp } from 'vue';
import Application from './Application.vue';
import AppMergeMiddleware from './middleware/middleware.js';

// Initialize middleware first
const middleware = new AppMergeMiddleware();

// Wait for middleware to initialize before mounting Vue app
middleware.initialize().then(() => {
  const app = createApp(Application);

  // Provide middleware to all components via dependency injection
  app.provide('middleware', middleware);

  app.mount('#app-merge');
}).catch(error => {
  console.error('Failed to initialize middleware:', error);
});
```

**Step 2: Inject Middleware in Components**

```vue
<script>
export default {
  name: 'MyComponent',

  // Inject middleware provided by parent
  inject: ['middleware'],

  data() {
    return {
      items: [],
      loading: false,
      error: null
    };
  },

  async mounted() {
    await this.loadData();
  },

  methods: {
    async loadData() {
      this.loading = true;
      this.error = null;

      try {
        // Access middleware through inject - it's guaranteed to exist
        if (this.middleware && this.middleware.core && this.middleware.core.apiClient) {
          const apiClient = this.middleware.core.apiClient;

          // Use the API client
          const response = await apiClient.get('v1/apps');
          this.items = response.apps || [];
        } else {
          // Fallback for development/testing
          this.items = [];
        }
      } catch (err) {
        this.error = err.message;
        console.error('Failed to load data:', err);
      } finally {
        this.loading = false;
      }
    }
  }
};
</script>
```

**Step 3: Correct Middleware Access Path**

‚úÖ **Correct:** Access API client through `middleware.core.apiClient`
```javascript
const apiClient = this.middleware.core.apiClient;
const response = await apiClient.get('v1/apps');
```

‚ùå **Incorrect:** Accessing through `middleware.api` (this is the services object, not the client)
```javascript
// This will fail - middleware.api is the services object, not the API client
const apiClient = this.middleware.api;
const response = await apiClient.get('v1/apps'); // Error: get is not a function
```

#### Component Property Ordering

Vue components should declare properties in this order:

```javascript
export default {
  name: 'ComponentName',          // 1. Component name

  inject: ['middleware'],         // 2. Dependency injection (before components!)

  components: {                   // 3. Child components
    SomeComponent
  },

  props: {                        // 4. Props
    // ...
  },

  emits: ['event-name'],          // 5. Emitted events

  data() {                        // 6. Reactive data
    return {
      // ...
    };
  },

  computed: {                     // 7. Computed properties
    // ...
  },

  watch: {                        // 8. Watchers
    // ...
  },

  created() {},                   // 9. Lifecycle hooks (in order)
  mounted() {},
  beforeUnmount() {},

  methods: {                      // 10. Methods (last)
    // ...
  }
};
```

**Note:** `inject` must come before `components` to ensure middleware is available for all child components.

### ES6 Module System Best Practices

**APPLICABILITY:** These guidelines apply only when using **ES6 modules with Babel and Webpack**. If your project uses:
- Pure vanilla JavaScript without a build system
- TypeScript (which handles modules differently)
- Different bundlers (Rollup, esbuild, Vite) with their own configurations
- CommonJS exclusively

...then these specific Babel + Webpack guidelines may not apply. Consult your build tool's documentation.

**CRITICAL (Babel + Webpack projects only):** Use pure ES6 modules throughout the middleware layer. Do not mix with CommonJS.

#### Why Pure ES6 Modules? (Babel + Webpack Context)

‚ùå **Problems with Mixed Module Systems:**
- Babel transforming ES6 to CommonJS creates `.default` wrapper objects
- EventEmitter and other class instantiation fails with "is not a constructor" errors
- Dual exports (both ES6 and CommonJS) create conflicts
- `module.exports` triggers "ES Modules may not assign module.exports" errors

‚úÖ **Benefits of Pure ES6:**
- Webpack 5 natively supports ES6 modules
- No `.default` wrapper issues
- Cleaner imports and exports
- Better tree-shaking and optimization
- Standard modern JavaScript

#### Babel Configuration (Babel + Webpack Projects)

**Note:** This configuration is specific to Babel + Webpack setups. Other build tools may have different configurations.

Configure Babel to preserve ES6 modules and let Webpack handle them:

**`.babelrc`**
```json
{
  "presets": [
    ["@babel/preset-env", {
      "modules": false
    }]
  ]
}
```

**Key Setting:** `"modules": false` tells Babel NOT to transform ES6 modules to CommonJS.

#### Correct Module Export Pattern

‚úÖ **Correct:** Pure ES6 default export
```javascript
// src/middleware/middleware.js
class AppMergeMiddleware {
  constructor() {
    // ...
  }

  initialize() {
    // ...
  }
}

// Only ES6 export - no module.exports
export default AppMergeMiddleware;
```

‚úÖ **Correct:** Pure ES6 named exports
```javascript
// src/middleware/utils/helpers.js
export function formatDate(date) {
  // ...
}

export function parseJSON(str) {
  // ...
}

export const CONSTANTS = {
  // ...
};
```

‚ùå **Incorrect:** Mixing ES6 and CommonJS
```javascript
// DON'T DO THIS - causes .default wrapper issues
class AppMergeMiddleware {
  // ...
}

export default AppMergeMiddleware;
module.exports = AppMergeMiddleware;  // ‚ùå Error: ES Modules may not assign
```

‚ùå **Incorrect:** Pure CommonJS in ES6 module context
```javascript
// DON'T DO THIS in ES6 module context
class AppMergeMiddleware {
  // ...
}

module.exports = AppMergeMiddleware;  // ‚ùå Error with ES6 modules
```

#### Correct Import Pattern

‚úÖ **Correct:** Pure ES6 imports
```javascript
// Import default export
import AppMergeMiddleware from './middleware/middleware.js';

// Import named exports
import { formatDate, parseJSON } from './utils/helpers.js';

// Import everything as namespace
import * as helpers from './utils/helpers.js';
```

‚ùå **Incorrect:** CommonJS require in ES6 context
```javascript
// DON'T DO THIS in ES6 module context
const AppMergeMiddleware = require('./middleware/middleware.js');
```

#### Webpack Configuration

Webpack 5 natively supports ES6 modules when Babel is configured correctly:

**`webpack.config.js`**
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              ['@babel/preset-env', {
                modules: false  // Let Webpack handle modules
              }]
            ]
          }
        }
      }
    ]
  }
};
```

#### Global Namespace Exposure (for Vue Integration)

After bundling, expose middleware to global namespace for Vue app initialization:

**`src/middleware/middleware.js` (end of file)**
```javascript
class AppMergeMiddleware {
  // ... class implementation
}

// ES6 default export for module system
export default AppMergeMiddleware;

// Also expose to global namespace for initialization in main.js
if (typeof window !== 'undefined') {
  window.AppMergeMiddleware = AppMergeMiddleware;
}
```

**`src/main.js`**
```javascript
import { createApp } from 'vue';
import Application from './Application.vue';
import AppMergeMiddleware from './middleware/middleware.js';

// Use imported class (ES6 module)
const middleware = new AppMergeMiddleware();

// Initialize and provide to Vue
middleware.initialize().then(() => {
  const app = createApp(Application);
  app.provide('middleware', middleware);
  app.mount('#app-merge');
});
```

### Critical Implementation Checklist

**Note:** This checklist applies to Vue 3 + Babel + Webpack projects. Skip items that don't apply to your technology stack.

Before generating UI implementation tasks, verify (if applicable):

1. **‚úÖ Babel Configuration (Babel + Webpack only):** `.babelrc` has `"modules": false` setting
2. **‚úÖ Pure ES6 Exports (ES6 module projects only):** All middleware files use only `export default` or `export { }` syntax
3. **‚úÖ No CommonJS (ES6 module projects only):** No `module.exports` or `require()` statements in ES6 modules
4. **‚úÖ Vue Dependency Injection (Vue 3 only):** `app.provide('middleware', middleware)` in main.js
5. **‚úÖ Component Injection (Vue 3 only):** All components use `inject: ['middleware']`
6. **‚úÖ Correct Access Path (project-specific):** Components access middleware through documented path (e.g., `middleware.core.apiClient`)
7. **‚úÖ Property Ordering (Vue Options API only):** `inject` comes before `components` in component definitions
8. **‚úÖ Middleware Initialization (all projects):** Middleware initialized before UI framework mounts
9. **‚úÖ Build Configuration (build system projects only):** Build tool configured to handle module system correctly

## Implementation Guidelines

### Package Dependencies Setup

**Required NPM Packages:**

Add these dependencies to `package.json`:

\`\`\`json
{
  "dependencies": {
    "vue": "^3.5.13",
    "lucide-vue-next": "^0.x.x",
    "core-js": "^3.39.0",
    "regenerator-runtime": "^0.14.1"
  },
  "devDependencies": {
    "tailwindcss": "^3.x.x",
    "postcss": "^8.x.x",
    "autoprefixer": "^10.x.x",
    "@tailwindcss/forms": "^0.5.x",
    "@tailwindcss/typography": "^0.5.x",
    "gulp": "^5.0.0",
    "gulp-sass": "^5.1.0",
    "sass": "^1.81.0",
    "webpack": "^5.96.1",
    "vue-loader": "^17.4.2",
    "@babel/core": "^7.26.0",
    "@babel/preset-env": "^7.26.0"
  }
}
\`\`\`

**Build Configuration:**

1. **Tailwind Config** (`tailwind.config.js`):
   - Configure content paths to scan for classes
   - Extend theme with Fliplet brand colors
   - Add required plugins

2. **PostCSS Config** (`postcss.config.js`):
   - Configure Tailwind processing
   - Add autoprefixer for browser compatibility

3. **Gulp/Webpack Build**:
   - Compile Tailwind CSS into `dist/css/index.css`
   - Bundle Vue components into `dist/app.js`
   - Ensure production builds purge unused CSS

### Fliplet Widget File Loading & Dependencies

**CRITICAL:** All CSS and JavaScript files must be properly declared in `widget.json` to be loaded by Fliplet. Files cannot be loaded independently - they must follow Fliplet's asset management system.

#### Widget.json Configuration

Every UI component file must be declared in `widget.json` under the appropriate context:

\`\`\`json
{
  "name": "Widget Name",
  "build": {
    "dependencies": [
      "fliplet-core"
    ],
    "assets": [
      "dist/css/index.css",
      "dist/app.js"
    ]
  },
  "interface": {
    "dependencies": [
      "fliplet-core"
    ],
    "assets": [
      "dist/css/interface.css",
      "dist/interface.js"
    ]
  }
}
\`\`\`

**Note:** With Tailwind CSS and Vue compiled through Gulp/Webpack:
- All component CSS is compiled into `dist/css/index.css` (includes Tailwind utilities)
- All component JavaScript is bundled into `dist/app.js` (includes Vue components and lucide-vue-next)
- Only the compiled/bundled files need to be declared in `widget.json`

#### Dependency Requirements

**Available Dependencies:** All dependencies must be available in [Fliplet's asset library](https://api.fliplet.com/v1/widgets/assets). Check the API endpoint before specifying any dependency.

**Context-Specific Loading:**
- **Build Context:** Files loaded in the published app for end users
- **Interface Context:** Files loaded in Fliplet Studio for configuration

#### File Organization Strategy

\`\`\`
/css/
‚îú‚îÄ‚îÄ build.css          # Compiled styles for end users
‚îú‚îÄ‚îÄ interface.css      # Compiled styles for Studio
‚îî‚îÄ‚îÄ components/        # Individual component styles (pre-build)
    ‚îú‚îÄ‚îÄ layout/
    ‚îú‚îÄ‚îÄ forms/
    ‚îî‚îÄ‚îÄ ui/

/js/
‚îú‚îÄ‚îÄ build.js           # Main entry point for end users
‚îú‚îÄ‚îÄ interface.js       # Main entry point for Studio
‚îî‚îÄ‚îÄ components/        # Individual components
    ‚îú‚îÄ‚îÄ layout/
    ‚îÇ   ‚îú‚îÄ‚îÄ app-shell.js
    ‚îÇ   ‚îî‚îÄ‚îÄ navigation-header.js
    ‚îú‚îÄ‚îÄ pages/
    ‚îÇ   ‚îî‚îÄ‚îÄ dashboard-view.js
    ‚îú‚îÄ‚îÄ forms/
    ‚îÇ   ‚îî‚îÄ‚îÄ settings-form.js
    ‚îî‚îÄ‚îÄ ui/
        ‚îú‚îÄ‚îÄ data-table.js
        ‚îî‚îÄ‚îÄ status-indicator.js
\`\`\`

#### HTML Template Integration

**Build Context Templates:** Must be in `build.html` or loaded via JavaScript:
\`\`\`html
<!-- build.html -->
<div id="app">
  <!-- Component templates go here -->
</div>

<!-- OR loaded dynamically -->
<script>
window.[WidgetName].templates = {
  'app-shell': '<div class="app-shell">...</div>',
  'data-table': '<table class="data-table">...</table>'
};
</script>
\`\`\`

**Interface Context Templates:** Must be in `interface.html` or loaded via JavaScript:
\`\`\`html
<!-- interface.html -->
<div class="widget-settings">
  <!-- Configuration UI templates -->
</div>
\`\`\`

#### Asset Loading Order

Files are loaded in the exact order listed in the `assets` array:

\`\`\`json
{
  "build": {
    "assets": [
      "css/base.css",           // 1. Base styles first
      "css/components.css",     // 2. Component styles
      "css/themes.css",         // 3. Theme overrides
      "js/utils.js",           // 4. Utilities first
      "js/components/base.js",  // 5. Base components
      "js/components/ui.js",    // 6. UI components
      "js/main.js"             // 7. Main application last
    ]
  }
}
\`\`\`

#### Build Optimization Options

**Option 1: Manual Compilation**
Use build tools (gulp, webpack) to compile multiple files:

\`\`\`json
{
  "build": {
    "assets": [
      "dist/app.min.css",    # Single compiled CSS
      "dist/app.min.js"      # Single compiled JS
    ]
  }
}
\`\`\`

**Option 2: Fliplet Auto-Concatenation**
List individual files - Fliplet automatically concatenates in production:

\`\`\`json
{
  "build": {
    "assets": [
      "css/base.css",
      "css/layout.css",
      "css/forms.css",
      "css/ui.css",
      "js/utils.js",
      "js/components.js",
      "js/main.js"
    ]
  }
}
\`\`\`

#### Vue.js 3.5.13 Component Loading

**Component Registration Pattern:**
\`\`\`javascript
// Each component file should register itself globally
(function() {
  'use strict';

  // Replace [WidgetName] with actual widget namespace
  window.[WidgetName] = window.[WidgetName] || {};
  window.[WidgetName].components = window.[WidgetName].components || {};

  // Register component
  window.[WidgetName].components['AppShell'] = {
    template: window.[WidgetName].templates['app-shell'],
    props: ['branding', 'navigation'],
    data() {
      return {
        // component state
      };
    },
    methods: {
      // component methods
    }
  };
})();
\`\`\`

**Main Application Registration:**
\`\`\`javascript
// main.js - loaded last in assets array
(function() {
  'use strict';

  // Create Vue app with all registered components
  window.[WidgetName].app = new Vue({
    el: '#app',
    components: window.[WidgetName].components,
    data: {
      // app state
    }
  });
})();
\`\`\`

#### Critical Implementation Checklist

Before generating UI implementation tasks, verify:

1. **‚úÖ Context Clarity:** Confirmed whether building for interface or build context
2. **‚úÖ Dependency Check:** All dependencies exist in [Fliplet's asset library](https://api.fliplet.com/v1/widgets/assets)
3. **‚úÖ File Declaration:** Every CSS/JS file listed in appropriate widget.json context
4. **‚úÖ Load Order:** Assets listed in correct loading sequence
5. **‚úÖ Template Strategy:** HTML templates integrated via build.html/interface.html or JavaScript
6. **‚úÖ Component Registration:** Vue components properly registered in global namespace
7. **‚úÖ Build Strategy:** Chosen between manual compilation vs Fliplet auto-concatenation

#### Example Implementation Reference

See [fliplet-widget-form-builder](https://github.com/Fliplet/fliplet-widget-form-builder/blob/master/widget.json) and [fliplet-widget-theme](https://github.com/Fliplet/fliplet-widget-theme/blob/master/widget.json) for complete examples of proper asset declaration and loading.

## Component Documentation

### Component Template

Example component using Tailwind CSS and lucide-vue-next icons:

\`\`\`vue
<template>
  <div
    class="bg-white rounded-lg shadow-md p-6 transition-all duration-200"
    :class="{
      'border-2 border-primary': isActive,
      'border border-error': hasError
    }"
  >
    <!-- Component header with icon -->
    <div class="flex items-center gap-3 mb-4">
      <CheckCircle2
        v-if="isSuccess"
        class="w-5 h-5 text-success"
        :stroke-width="2"
      />
      <AlertCircle
        v-else-if="hasError"
        class="w-5 h-5 text-error"
        :stroke-width="2"
      />

      <h3 class="text-lg font-semibold text-gray-900">
        {{ title }}
      </h3>
    </div>

    <!-- Component content -->
    <div class="text-sm text-gray-600">
      <slot />
    </div>

    <!-- Action button -->
    <button
      v-if="showAction"
      @click="handleAction"
      class="mt-4 bg-primary hover:bg-primary-600 text-white font-medium py-2 px-4 rounded transition-colors inline-flex items-center gap-2"
      :disabled="isLoading"
    >
      <Loader2
        v-if="isLoading"
        class="w-4 h-4 animate-spin"
      />
      <span>{{ actionLabel }}</span>
    </button>
  </div>
</template>

<script>
import { CheckCircle2, AlertCircle, Loader2 } from 'lucide-vue-next';

/**
 * ComponentName - Brief description
 * Vue 3.5.13 component using Options API with Tailwind CSS
 *
 * @example
 * <ComponentName
 *   title="Example Title"
 *   :is-active="true"
 *   @action="handleAction"
 * >
 *   Content goes here
 * </ComponentName>
 */
export default {
  name: 'ComponentName',

  components: {
    CheckCircle2,
    AlertCircle,
    Loader2
  },

  props: {
    /**
     * Component title
     * @type {String}
     * @required
     */
    title: {
      type: String,
      required: true
    },

    /**
     * Whether component is in active state
     * @type {Boolean}
     */
    isActive: {
      type: Boolean,
      default: false
    },

    /**
     * Whether to show action button
     * @type {Boolean}
     */
    showAction: {
      type: Boolean,
      default: false
    },

    /**
     * Action button label
     * @type {String}
     */
    actionLabel: {
      type: String,
      default: 'Submit'
    }
  },

  // Events: action

  data() {
    return {
      isLoading: false,
      hasError: false,
      isSuccess: false
    };
  },

  methods: {
    async handleAction() {
      try {
        this.isLoading = true;
        this.hasError = false;

        // Emit action event
        this.$emit('action');

        this.isSuccess = true;
      } catch (error) {
        this.hasError = true;
        console.error('Action failed:', error);
      } finally {
        this.isLoading = false;
      }
    }
  },

  mounted() {
    // Component mounted
  },

  beforeUnmount() {
    // Cleanup before component destruction (Vue 3)
  }
};
</script>

<style scoped>
/* Use Tailwind classes in template - minimal custom CSS needed */
/* Only add custom CSS for complex animations or unique requirements */
</style>
\`\`\`

## Testing Strategy

### Component Testing
- **Unit Tests:** Test component logic in isolation
- **Integration Tests:** Test component with middleware
- **Visual Tests:** Screenshot comparisons
- **Accessibility Tests:** Automated a11y testing

### User Testing
- **Usability Testing:** Task-based user testing
- **A/B Testing:** Test different UI variations
- **Performance Testing:** Load time metrics
- **Device Testing:** Cross-device compatibility

## QA Test Plan Generation

The UI/UX plan should provide sufficient detail for generating a comprehensive Test Plan for QA verification. This Test Plan will be generated as a separate task and file (`test-plan-[project-name].md`) based on the UI specifications.

### Test Plan Requirements

The UI plan must include enough detail for QA to verify:

#### Functional Testing Areas
- **State Verification:** Each UI state defined in the State-Oriented UX Specs
- **User Flow Testing:** Complete user journeys from entry to completion
- **Form Validation:** All validation rules and error messages
- **Data Display:** Correct data rendering and formatting
- **Interactive Elements:** Button behavior, navigation, and user controls
- **Permission Testing:** Role-based access and feature flag verification

#### Cross-Platform Testing Scope
- **Responsive Behavior:** Mobile, tablet, desktop breakpoint testing
- **Browser Compatibility:** Testing matrix for supported browsers
- **Device Testing:** Touch interactions, keyboard navigation
- **Accessibility Testing:** Screen reader compatibility, keyboard navigation

#### Edge Case Testing Scenarios
- **Empty States:** No data available scenarios
- **Error States:** Network failures, API errors, validation failures
- **Loading States:** Long-running operations, timeout handling
- **Permission States:** Unauthorized access, insufficient privileges
- **Offline Scenarios:** Network connectivity issues

#### Performance Testing Benchmarks
- **Load Time Targets:** Based on performance optimization requirements
- **User Interaction Response:** Click-to-feedback timing requirements
- **Memory Usage:** Resource consumption limits
- **Network Usage:** Data transfer optimization verification

### Test Plan Generation Process

1. **Extract Testable Requirements:** From UI states, user flows, and component specifications
2. **Map Test Scenarios:** Each state transition and user action becomes a test case
3. **Define Success Criteria:** Measurable outcomes for each test scenario
4. **Create Test Data Requirements:** Mock data, user accounts, and system states needed
5. **Document Expected Behaviors:** Precise descriptions of correct system responses

## Implementation Priorities

### Phase 1: Core Components
1. AppShell and navigation
2. Basic form components
3. Data display components
4. Error handling components

### Phase 2: Advanced Features
1. Complex workflows
2. Data visualization
3. Advanced filtering
4. Batch operations

### Phase 3: Polish & Optimization
1. Animation refinements
2. Performance optimization
3. Advanced theming
4. Enhanced accessibility

## Success Metrics

### User Experience Metrics
- **Task Completion Rate:** 95%+ successful completions
- **Time to Complete:** Reduced by 30% from current
- **Error Rate:** Less than 5% user errors
- **Satisfaction Score:** 4.5+ out of 5

### Technical Metrics
- **Load Time:** Initial load under 3 seconds
- **Accessibility Score:** 100% WCAG 2.1 AA compliance
- **Browser Support:** Modern browsers + IE11
- **Device Support:** Responsive from 320px width

### Design System Metrics
- **Component Reuse:** 80%+ shared components
- **Theme Adoption:** Easy customization demonstrated
- **Documentation Coverage:** 100% components documented
- **Design Consistency:** Style guide adherence

## File Structure Plan

\`\`\`
/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ui-config.js            # UIConfig for mode switching (mock/middleware/hybrid)
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DataService.js          # Data abstraction layer
‚îÇ   ‚îú‚îÄ‚îÄ mocks/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MockDataService.js      # Mock data service implementation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fixtures.js             # Mock data fixtures
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ scenarios.js            # Test scenarios (errors, loading, empty states)
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AppShell.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NavigationHeader.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PageContainer.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ FooterSection.vue
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [PageName]View.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ forms/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [FormName]Form.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FormField.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ValidationMessage.vue
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DataTable.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StatusIndicator.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ActionButton.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LoadingSpinner.vue
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ feedback/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NotificationToast.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ModalDialog.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ErrorBoundary.vue
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ shared/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ BaseComponent.vue
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ TransitionWrapper.vue
‚îÇ   ‚îú‚îÄ‚îÄ scss/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.scss              # Tailwind directives and custom styles
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validators.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ formatters.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ accessibility.js
‚îÇ   ‚îú‚îÄ‚îÄ Application.vue             # Root Vue component
‚îÇ   ‚îî‚îÄ‚îÄ main.js                     # Vue app initialization
‚îú‚îÄ‚îÄ dist/
‚îÇ   ‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.css               # Compiled Tailwind + custom CSS
‚îÇ   ‚îî‚îÄ‚îÄ app.js                      # Bundled Vue app + components
‚îú‚îÄ‚îÄ build.html                      # Widget HTML template (build context)
‚îú‚îÄ‚îÄ interface.html                  # Widget HTML template (interface context)
‚îú‚îÄ‚îÄ tailwind.config.js              # Tailwind theme configuration
‚îú‚îÄ‚îÄ postcss.config.js               # PostCSS configuration
‚îú‚îÄ‚îÄ gulpfile.js                     # Gulp build tasks
‚îú‚îÄ‚îÄ package.json                    # NPM dependencies
‚îî‚îÄ‚îÄ widget.json                     # Fliplet widget configuration
\`\`\`

**Key Files:**

**Mock-First Infrastructure:**
- **`src/config/ui-config.js`** - UIConfig object for mode switching (mock/middleware/hybrid)
- **`src/services/DataService.js`** - Data abstraction layer (single interface for all data operations)
- **`src/mocks/MockDataService.js`** - Mock implementation with realistic behavior
- **`src/mocks/fixtures.js`** - Mock data for all scenarios
- **`src/mocks/scenarios.js`** - Test scenario helpers (errors, loading, etc.)

**Styling:**
- **`src/scss/index.scss`** - Main SCSS file with Tailwind directives:
  \`\`\`scss
  @tailwind base;
  @tailwind components;
  @tailwind utilities;

  // Custom component classes (use @apply sparingly)
  // Additional custom styles as needed
  \`\`\`

**Build Outputs:**
- **`tailwind.config.js`** - Tailwind configuration with Fliplet brand tokens
- **`dist/css/index.css`** - Compiled output (referenced in widget.json)
- **`dist/app.js`** - Bundled Vue app (referenced in widget.json)

## Next Steps

This UI/UX plan should be reviewed for:
1. **User Experience:** Intuitive workflows and clear interactions
2. **Visual Design:** Consistent with Fliplet brand guidelines
3. **Technical Feasibility:** Vue.js 3.5.13 implementation approach
4. **Accessibility:** WCAG 2.1 AA compliance throughout
5. **Performance:** Optimal loading and runtime performance

Once approved, this plan will be converted to implementation tasks using `generate-tasks.mdc`.
```

## Plan Generation Guidelines

### Comprehensive Analysis
- Read the complete middleware architecture plan
- Understand all user workflows and data flows
- Identify every user interaction point
- Map all states (loading, error, success, empty)

### UI/UX Design
- **Design beautiful, production-worthy interfaces** - not cookie-cutter templates
- **Use Tailwind CSS exclusively** for all styling (no custom CSS frameworks)
- **Use lucide-vue-next** for all icons (no other icon libraries unless absolutely necessary)
- Design for non-technical users first
- Ensure responsive mobile-first approach
- Plan for accessibility from the start
- Focus on visual excellence and user delight

### Documentation Quality
- Use clear, non-technical language where possible
- Include visual examples and code snippets
- Ensure compatibility with task generation
- Provide implementation guidance

### Review Considerations
- Design decisions should be clear to non-developers
- Customization options should be well-documented
- Accessibility requirements must be specific
- Performance targets should be measurable

## Target Audience

The generated plan should be suitable for:
- **Product Managers** reviewing user experience decisions
- **Designers** understanding component structure and theming
- **Developers** who will implement the components
- **QA Engineers** understanding UI behavior and states
- **Stakeholders** reviewing brand compliance

## Final Instructions

1. **Design Philosophy** - Create beautiful, production-worthy interfaces, not cookie-cutter designs
2. **Mock-First Development** - CRITICAL: UI must work independently with mock data using UIConfig
   - Plan UIConfig, DataService, MockDataService, fixtures, and scenarios
   - Components NEVER directly access middleware - always use DataService abstraction
   - Default to `UIConfig.mode = 'mock'` for parallel development
   - Enable progressive integration via hybrid mode
3. **Check widget context** - Clarify if building for interface or build context
4. **Review Fliplet documentation** - Use the reference table to understand constraints
5. **Analyze the middleware architecture** thoroughly before beginning (but don't depend on it)
6. **Use Tailwind CSS exclusively** (Vue projects) - All styling must use Tailwind utility classes
7. **Use lucide-vue-next for icons** (Vue projects) - Do not use other icon libraries unless absolutely necessary
8. **Design for Vue.js 3.5.13** (Vue projects) - Use Options API for compatibility
9. **Configure Tailwind theme** (Tailwind projects) - Extend with Fliplet brand colors, spacing, and design tokens
10. **Plan NPM dependencies** - List all required packages in package.json
11. **Plan build process** - Ensure proper compilation through build tools into dist/ folder
12. **Apply module system guidelines** (Babel + Webpack projects) - Follow ES6 module patterns in "Vue Dependency Injection & Module System" section
13. **Apply dependency injection** (Vue 3 projects) - Use provide/inject pattern instead of global variables
14. **Create a complete UI/UX plan** that addresses every user touchpoint
15. **Ensure the plan structure** matches the required format exactly
16. **Use generic naming** - Replace [WidgetName], [project-name] with actual values
17. **Include specific details** that can be converted to actionable tasks
18. **Plan for accessibility** and responsive design throughout (WCAG 2.1 AA)
19. **Focus on visual excellence** - Attention to spacing, typography, colors, and interactions
20. **Consider non-technical reviewers** in your language choices
21. **Prepare for task generation** by including implementation details
22. **Follow implementation guidelines** - Only compiled files (dist/) declared in widget.json
23. **Fliplet dependencies** - Only fliplet-core is required; avoid fliplet-studio-ui, bootstrap-css
24. **Enable rapid prototyping** - UI should be demonstrable to stakeholders without functional middleware
