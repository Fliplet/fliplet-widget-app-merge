---
description: Generating Middleware Architecture Plans from REST API Documentation
globs:
alwaysApply: false
---
# Rule: Generating Middleware Architecture Plans from REST API Documentation

## Goal

To guide an AI assistant in analyzing existing documents including (but not limited to) PRD, design specs, REST API specs and creating a comprehensive middleware architecture plan that serves as the foundation for subsequent task generation and implementation. The plan ensures proper workflow enforcement, data integrity, and UI-agnostic design.

## Output

- **Format:** Markdown (`.md`)
- **Location:** `/tasks/`
- **Filename:** `middleware-plan-[project-name].md`
- **Purpose:** Comprehensive architecture plan ready for task generation

## Process

1. **Analyze API Documentation:** Read and thoroughly analyze all provided REST API documentation files
2. **Identify System Patterns:** Extract workflows, dependencies, data structures, and business rules
3. **Design Architecture:** Create a complete middleware architecture that enforces proper sequencing
4. **Map Components:** Define all classes, services, and controllers needed
5. **Plan Integration:** Design how components will work together
6. **Generate Plan Document:** Create structured markdown plan ready for task generation

## Input Requirements

The AI should analyze the following from API documentation:

### API Documentation Files
- **API Endpoints:** Complete endpoint documentation with request/response schemas
- **API Flows:** Workflow sequences and dependencies
- **Sequence Diagrams:** Visual workflow representations
- **Implementation Guidelines:** Frontend integration patterns

### Key Analysis Areas
- **Workflow Dependencies:** Sequential steps that must be enforced
- **Data Validation:** Required fields, types, and business rules
- **Error Handling:** All error codes and recovery strategies
- **State Management:** Data persistence and state transitions
- **Authentication:** Security and authorization requirements

## Architecture Plan Structure

The generated plan must follow this exact structure for compatibility with `generate-tasks.mdc`:

```markdown
# Middleware Architecture Plan: [Project Name]

## Overview
[Brief description of the middleware system and its purpose]

## System Architecture

### Core Principles

**Foundation Philosophy:**
- **Behavior-Parameterized Design**: Middleware accepts parameters describing *what behavior is needed*, never *who is calling*
- **Caller-Agnostic Implementation**: No coupling to specific UI contexts, screens, or device types
- **Intent-Based Signatures**: Function parameters express behavioral options, not caller identity
- **Explicit Over Implicit**: All behavior must be explicitly requested through parameters, no magic defaults based on caller assumptions
- **Design-Time Awareness, Runtime Agnosticism**: Review PRD/specs to understand usage patterns, but never hardcode assumptions about callers

**Reference:** See `docs/middleware-dev-guidelines.md` for detailed philosophy and examples.

**Architecture Principles:**
- Workflow Enforcement: [How sequential processes are enforced]
- Data Integrity: [How data validation is implemented]
- State Management: [How application state is managed]
- Error Handling: [How errors are caught and handled]
- API Abstraction: [How REST APIs are wrapped with behavior-driven interfaces]

### Component Hierarchy
[Visual representation of class relationships and dependencies]

### Middleware Design Principles

#### Intent-Based Function Signatures

**DO:** Accept parameters that describe *what behavior is needed*
\`\`\`typescript
// ✓ Behavior-driven parameters
fetchApps({
  fields: ['id', 'name', 'lastModified'],
  filters: { organisationId: '123', isPublished: true },
  pagination: { page: 1, limit: 25 },
  sortBy: { field: 'lastModified', order: 'desc' },
  include: ['organisation', 'settings']
})
\`\`\`

**DON'T:** Accept parameters that identify *who is calling*
\`\`\`typescript
// ❌ Caller identification
fetchApps(orgId, callerType: 'dashboard' | 'mobile' | 'admin')
fetchApps(orgId, { isMobileView: true, isDashboard: false })
\`\`\`

#### API Response Transformation

**Driven by Options, Not Assumptions:**
- Transform REST API responses based on the `fields` parameter passed in
- If the REST API returns more data than requested, filter it according to options
- Construct API requests from behavioral parameters, not caller context
- Never create different response shapes based on assumed caller identity

**Example:**
\`\`\`javascript
// ✓ Transformation based on explicit options
function transformAppResponse(apiResponse, options = {}) {
  const { fields, include } = options;

  let result = apiResponse;

  // Filter fields if specified
  if (fields && fields.length > 0) {
    result = fields.reduce((obj, field) => {
      if (apiResponse[field] !== undefined) {
        obj[field] = apiResponse[field];
      }
      return obj;
    }, {});
  }

  // Include related resources if specified
  if (include && include.length > 0) {
    // Fetch and attach related resources
  }

  return result;
}
\`\`\`

#### State Management Integration

**Cache Keys Based on Request Parameters:**
- State structure should be **deterministic** based on data, not caller
- Cache keys must be derived from **request parameters**, not caller identity
- Provide cache control options: `{ cache: 'force-refresh' | 'cache-first' | 'network-only' }`

**Example:**
\`\`\`javascript
// ✓ Cache key from request parameters
function generateCacheKey(endpoint, options) {
  return `${endpoint}:${JSON.stringify(options)}`;
}

// ❌ Cache key from caller identity
function generateCacheKey(endpoint, callerType) {
  return `${endpoint}:${callerType}`;
}
\`\`\`

#### Data Fetching Patterns

**When PRD/design shows different UIs need different data:**
- ✓ Implement field selection: `{ fields: ['id', 'name', 'avatar'] }`
- ✓ Implement inclusion of relations: `{ include: ['profile', 'settings'] }`
- ✓ Implement depth control: `{ depth: 1 }` for shallow vs deep fetching
- ✓ Implement pagination: `{ page: 1, limit: 25 }`
- ❌ Don't implement: `{ clientType: 'dashboard' }` or `{ viewMode: 'mobile' }`

**Performance as Opt-In:**
- Let callers opt into performance features rather than guessing when to apply them
- Implement caching options that callers can enable
- Implement batch operation support where the REST API allows it
- Provide pagination capabilities without assuming when to use them

#### Critical Thinking for Design

Before implementing any middleware function, validate:
1. **Could this function serve a caller I haven't thought of yet?**
2. **Are my parameters describing *what to do* or *who is asking*?**
3. **If the UI completely changes tomorrow, would this function still make sense?**
4. **Can I explain every parameter's purpose without referring to specific screens or devices?**

If you answer "no" to any of these, reconsider the design.

## Functional Requirements

### FR1: [Requirement Name]
**Description:** [Clear description of what this component must do]
**Dependencies:** [What other components this depends on]
**Validation Rules:** [Data validation requirements]
**Error Handling:** [Specific error scenarios and responses]

### FR2: [Next Requirement]
[Continue for all major functional requirements]

## Technical Architecture

### Core Foundation Classes

#### BaseMiddleware
**Purpose:** [Foundation class responsibilities]
**Key Methods:** [Primary methods this class will provide]
**Dependencies:** [What this class depends on]

#### StateManager
**Purpose:** [State management responsibilities]
**State Schema:** [Structure of application state]
**Validation Rules:** [State transition validation]

#### ValidationEngine
**Purpose:** [Data validation responsibilities]
**Validation Types:** [Types of validation performed]
**Integration:** [How it integrates with other components]

### API Service Classes

#### ApiClient
**Purpose:** [HTTP communication responsibilities using Fliplet.API.request()]
**Features:** [Authentication, retry logic, error handling via Fliplet API]
**Configuration:** [How it wraps Fliplet.API.request() and handles responses]
**Implementation:** Must use Fliplet.API.request() as documented at https://developers.fliplet.com/API/core/api.html.

**CRITICAL IMPLEMENTATION REQUIREMENTS:**
1. **No baseUrl needed:** Fliplet.API.request() automatically uses `Fliplet.Env.get('apiUrl')` as the default base URL, returning 'https://api.fliplet.com/' for production and 'https://staging.api.fliplet.com/' for staging etc.
2. **Custom API URL:** Check `Fliplet.Navigate.query.apiUrl` and pass it as `{ apiUrl }` option to Fliplet.API.request() only when provided
3. **Custom Auth Token:** Check `Fliplet.Navigate.query.auth_token` and pass it as `{ headers: { 'Auth-token': auth_token } }` option
4. **URL handling:** Fliplet.API.request() expects base URL to end with trailing slash and endpoint to start without slash (e.g., apiUrl: 'https://api.fliplet.com/', url: 'v1/submissions')

**Example Implementation Pattern:**
\`\`\`javascript
// Constructor - no baseUrl needed
this.config = {
  timeout: 30000,
  retryAttempts: 3,
  retryDelay: 1000,
  // ... other config
};

// Check for overrides from Fliplet.Navigate.query
this.apiUrl = null; // Only set if custom apiUrl provided
this.authToken = null;

if (typeof Fliplet !== 'undefined' && Fliplet.Navigate && Fliplet.Navigate.query) {
  if (Fliplet.Navigate.query.apiUrl) {
    this.apiUrl = Fliplet.Navigate.query.apiUrl;
  }
  if (Fliplet.Navigate.query.auth_token) {
    this.authToken = Fliplet.Navigate.query.auth_token;
  }
}

// In request method
const requestConfig = {
  url: this.buildRequestUrl(endpoint, params), // Handles both cases
  method: method.toUpperCase(),
  headers: this.buildRequestHeaders(customHeaders)
};

// Add custom apiUrl only if provided
if (this.apiUrl) {
  requestConfig.apiUrl = this.apiUrl;
}

// buildRequestUrl method handles both cases:
// - No custom apiUrl: return 'v1/submissions' (Fliplet.API.request() adds base URL with trailing slash)
// - Custom apiUrl: return 'https://custom.api.com/v1/submissions' (full URL when custom apiUrl provided)
\`\`\`

#### [Domain]ApiService Classes
[For each major API domain, define:]
**Purpose:** [What API endpoints this service wraps]
**Methods:** [Key methods corresponding to endpoints using behavioral options]

**Method Design Guidelines:**
- Use **options objects** with descriptive, behavioral parameters
- Accept parameters describing what data/behavior is needed, not who is calling
- Example method signature:
  \`\`\`javascript
  fetchItems(id, options = {
    fields: [],        // Which data fields to return
    include: [],       // Related resources to include
    filters: {},       // Data filtering criteria
    pagination: {},    // Page number and limit
    sort: {},         // Sort field and order
    cache: 'default'  // Cache strategy
  })
  \`\`\`
- **Avoid** caller-identifying parameters like `callerType`, `isMobile`, `viewMode`
- **Avoid** implicit behavior based on internal logic or environment detection

**Validation:** [Request/response validation based on explicit parameters]
**Error Mapping:** [How API errors are transformed into consistent error objects]

### Workflow Controller Classes

#### WorkflowManager
**Purpose:** [Workflow orchestration responsibilities]
**Workflow Types:** [Different workflows it manages]
**Dependencies:** [How it enforces sequential execution]

#### [Process]Controller Classes
[For each major workflow, define:]
**Purpose:** [What business process this controls]
**Steps:** [Sequential steps in the workflow]

**Controller Design Guidelines:**
- Controllers orchestrate workflows using **behavioral configuration**, not caller context
- Accept options that control workflow behavior (validation depth, rollback strategy, notification preferences)
- Provide granular, compositional options over high-level "modes"
- Example:
  \`\`\`javascript
  executeWorkflow(workflowId, options = {
    validation: 'strict' | 'lenient',  // How to validate steps
    parallel: false,                    // Execute steps in parallel where possible
    rollbackOn: 'error' | 'failure',   // Rollback strategy
    notify: true,                       // Send progress notifications
    checkpoints: []                     // Steps where state is persisted
  })
  \`\`\`
- **Design for reusability** across different UI contexts
- If the UI completely changes, the controller should still be useful

**Validation:** [Prerequisites and data requirements based on workflow options]
**State Management:** [How workflow state is tracked using deterministic keys]

### Supporting Infrastructure

#### ErrorHandler
**Purpose:** [Error management responsibilities]
**Error Categories:** [Types of errors handled]
**Recovery Strategies:** [How errors are resolved]
**User Experience:** [How errors are presented to users]

#### DataMapper
**Purpose:** [Data transformation responsibilities]
**Transformations:** [Types of data transformation]
**Validation:** [Data integrity checks]

## API Integration Mapping

### Endpoint Groups
[Group related endpoints and map to service classes]

#### [Group Name] (Maps to [ServiceClass])
- **GET [endpoint]** → [method_name]: [purpose]
- **POST [endpoint]** → [method_name]: [purpose]
- **PUT [endpoint]** → [method_name]: [purpose]
- **DELETE [endpoint]** → [method_name]: [purpose]

### Workflow Sequences
[Map API flow documentation to controller classes]

#### [Workflow Name] (Maps to [ControllerClass])
**Steps:**
1. [Step name] → [API call] → [validation] → [state update]
2. [Step name] → [API call] → [validation] → [state update]
[Continue for all steps]

**Dependencies:** [Prerequisites that must be satisfied]
**Validation Points:** [Where data integrity is checked]
**Error Handling:** [How failures are managed]

## State Management Design

### State Schema
\`\`\`javascript
{
  workflows: {
    [workflowName]: {
      currentStep: string,
      progress: number,
      data: object,
      errors: array,
      isComplete: boolean,
      dependencies: array
    }
  },
  cache: {
    [apiEndpoint]: {
      data: object,
      timestamp: string,
      ttl: number
    }
  },
  user: {
    // User session data
  },
  config: {
    // Application configuration
  }
}
\`\`\`

### State Transitions
[Define valid state transitions and validation rules]

### Persistence Strategy
[How state is persisted across sessions]

## Validation Framework Design

### Validation Rules
[Extract all validation requirements from API documentation]

#### Field Validation
- **Required Fields:** [List all required fields by endpoint]
- **Data Types:** [Type validation requirements]
- **Format Validation:** [Pattern matching requirements]
- **Range Validation:** [Min/max values and lengths]

#### Business Rules
- **Cross-field Validation:** [Dependencies between fields]
- **Conditional Requirements:** [Platform-specific requirements]
- **Workflow Validation:** [Sequential step requirements]

### Error Messages
[Map all API error codes to user-friendly messages]

## Error Handling Strategy

### Error Categories
1. **Validation Errors:** [Client-side validation failures]
2. **API Errors:** [Server-side errors and responses]
3. **Network Errors:** [Connectivity and timeout issues]
4. **Business Logic Errors:** [Workflow and dependency failures]

### Recovery Strategies
[Define how each error category should be handled]

### User Experience
[How errors are presented and what actions users can take]

## Anti-Patterns to Avoid

Document these anti-patterns explicitly in the plan to guide implementation:

### Caller Identification
❌ **Never accept parameters that identify who is calling:**
\`\`\`javascript
// ❌ Bad: Caller identification
function fetchData(id, source: 'mobile' | 'web' | 'admin')
function fetchData(id, { isMobileView: true, isDashboard: false })
function fetchData(id, callerType)
\`\`\`

### Hidden Branching Logic
❌ **Never use implicit branching based on caller context:**
\`\`\`javascript
// ❌ Bad: Hidden branching
function fetchData(id) {
  if (someInternalCheck) { return minimalData; }
  return fullData;
}
\`\`\`

### Overloaded Boolean Flags
❌ **Never use ambiguous boolean parameters:**
\`\`\`javascript
// ❌ Bad: What does "fast" mean?
function fetchData(id, fast: boolean)
\`\`\`

### Magic Strings Without Clear Semantics
❌ **Never use mode strings without clear behavioral meaning:**
\`\`\`javascript
// ❌ Bad: What's the difference between these?
function fetchData(id, mode: 'quick' | 'full' | 'detailed')
\`\`\`

### Environmental Detection
❌ **Never detect caller context from environment:**
\`\`\`javascript
// ❌ Bad: Detecting device type
function fetchData(id) {
  if (window.innerWidth < 768) {
    return minimalData;
  }
  return fullData;
}
\`\`\`

### Proper Alternatives

✓ **Instead, use explicit behavioral options:**
\`\`\`javascript
// ✓ Good: Explicit behavioral parameters
function fetchData(id, options = {
  fields: [],        // What data to include
  depth: 1,          // How deep to fetch relations
  cache: true,       // Whether to use cache
  priority: 'normal' // Request priority
})
\`\`\`

## Integration Patterns

### Dependency Injection
[How components are wired together]

### Event System
[How components communicate via events]

### Configuration Management
[How the system is configured and initialized]

## Testing Foundations

### Framework & Conventions
- [Selected framework and rationale, e.g., Jest for vanilla JS]
- [Directory layout for tests, e.g., src/**/Class.test.js alongside implementation]
- [Coverage targets and thresholds]

### Setup Artifacts
- [Configuration files to include, e.g., jest.config.js, tests/setup.js]
- [npm scripts to add: "test", "test:watch", "test:coverage"]
- [Mocking strategy for Fliplet APIs (e.g., MSW or stubbed globals)]

### Execution & CI
- [Commands to run tests locally]
- [How tests are invoked in CI and required to pass before merges]

## File Structure Plan

\`\`\`
/src/middleware/
├── core/
│   ├── BaseMiddleware.js
│   ├── StateManager.js
│   ├── ValidationEngine.js
│   ├── ErrorHandler.js
│   └── DataMapper.js
├── api/
│   ├── ApiClient.js
│   ├── [List all planned API service files]
│   └── ...
├── controllers/
│   ├── WorkflowManager.js
│   ├── [List all planned controller files]
│   └── ...
├── config/
│   ├── endpoints.js
│   ├── validation-rules.js
│   ├── error-messages.js
│   └── workflows.js
└── middleware.js
\`\`\`

## Implementation Considerations

### Development Approach
- **No Module System:** Pure vanilla JavaScript with global namespace
- **Fliplet API Integration:** ALL HTTP requests must use Fliplet.API.request() (https://developers.fliplet.com/API/core/api.html)
- **Dependency Injection:** Constructor-based dependency injection
- **Event-Driven:** Event system for component communication
- **Self-Documenting:** Comprehensive JSDoc documentation

### Testing Strategy

**Caller-Agnostic Testing Principles:**
- **Test behavior under different option combinations**, not "caller types"
- **Verify determinism**: Same options always produce the same behavior
- **Test edge cases**: Empty options, maximum options, invalid combinations
- **No caller simulation**: Don't write tests that simulate different "mobile" vs "web" contexts
- **Example:**
  \`\`\`javascript
  // ✓ Good: Test different behavioral options
  test('fetchApps with minimal fields', () => {
    const result = fetchApps({ fields: ['id', 'name'] });
    expect(result).toHaveOnlyFields(['id', 'name']);
  });

  test('fetchApps with full fields', () => {
    const result = fetchApps({ fields: ['id', 'name', 'owner', 'settings'] });
    expect(result).toHaveOnlyFields(['id', 'name', 'owner', 'settings']);
  });

  // ❌ Bad: Test caller types
  test('fetchApps for mobile returns minimal data', () => {
    const result = fetchApps({ callerType: 'mobile' });
    // ...
  });
  \`\`\`

**Framework & Setup:**
- **Framework Detection (existing codebases):** Before planning tests, identify if a framework already exists by checking for files like `jest.config.*`, `vitest.config.*`, test directories (`__tests__`, `tests`, `*.test.js`), and `package.json` scripts (`test`). If present, conform to existing conventions (folders, scripts, matchers, setup files).
- **Bootstrapping (new projects):** If no framework is detected, the plan MUST include a dedicated "Testing Foundations" section that specifies:
  - Framework: Prefer Jest for vanilla JavaScript projects
  - Config files: `jest.config.js`, `tests/setup.js` (global stubs for `Fliplet`), and optional `tests/mocks/`
  - Scripts: add `"test": "jest"`, `"test:watch": "jest --watch"`, `"test:coverage": "jest --coverage"` to `package.json`
  - Test placement: colocate `*.test.js` files next to the code they verify
  - Minimum coverage thresholds and how to enforce them
  - How to mock Fliplet APIs (e.g., global `Fliplet` stubs or MSW when HTTP is required)

**Test Coverage:**
- **Unit Tests:** One test file per class, testing all option combinations
- **Integration Tests:** Workflow testing scenarios with different configurations
- **Mock Data:** Complete mock datasets representing various option states
- **Error Simulation:** Test all error conditions, ensuring consistent handling regardless of options

### Performance Considerations
- **Caching Strategy:** [How API responses will be cached]
- **State Optimization:** [How state updates will be optimized]
- **Memory Management:** [How memory usage will be controlled]

## Success Metrics

### Functional Success
- **Workflow Enforcement:** Users cannot skip required steps
- **Data Integrity:** Invalid data is caught before API calls
- **Error Recovery:** All error conditions have proper handling
- **State Consistency:** Application state remains valid

### Technical Success
- **API Abstraction:** UI code never directly calls REST APIs
- **Code Reusability:** Components can be reused across projects
- **Maintainability:** Clear separation of concerns and documentation
- **Testability:** All components have comprehensive test coverage

### Design Quality Success
- **Caller Agnosticism:** Middleware functions can serve any caller without modification
- **Parameter Clarity:** Every parameter describes behavior, not caller identity
- **Future-Proof Design:** Functions remain valid if UI completely changes
- **Self-Documenting:** Parameters are self-explanatory without referring to specific screens or devices
- **Behavioral Composition:** Complex behaviors can be achieved by combining simple options
- **Deterministic Behavior:** Same options always produce the same result

## Middleware Design Validation Checklist

Before finalizing the architecture plan, validate each middleware function design against these criteria:

### Caller Agnosticism Validation
- [ ] Could this function serve a caller I haven't thought of yet?
- [ ] Are parameters describing *what to do* or *who is asking*?
- [ ] If the UI completely changes tomorrow, would this function still make sense?
- [ ] Can I explain every parameter's purpose without referring to specific screens or devices?

### Parameter Design Validation
- [ ] Are all behaviors explicitly opt-in through parameters?
- [ ] Is there any hidden branching based on caller identity?
- [ ] Are options objects used instead of positional parameters?
- [ ] Do all parameters have clear, self-documenting names?
- [ ] Are there any boolean flags that could be replaced with explicit enums?

### State & Caching Validation
- [ ] Do cache keys depend only on request parameters, not caller context?
- [ ] Is state structure deterministic based on data, not caller?
- [ ] Are cache control options explicitly provided to callers?
- [ ] Can the same parameters produce different results based on hidden state?

### API Integration Validation
- [ ] Are REST API responses transformed based on explicit options?
- [ ] Is there any caller-specific response formatting?
- [ ] Are API errors mapped consistently regardless of caller?
- [ ] Can callers control API request behavior through options?

### Documentation Validation
- [ ] Is there documentation explaining the design rationale without mentioning specific UIs?
- [ ] Are usage examples provided showing different option combinations?
- [ ] Are all parameters documented with their behavioral purpose?
- [ ] Is it clear which options are mutually exclusive or interdependent?

**If any checkbox cannot be checked, the design must be reconsidered.**

## Next Steps

This architecture plan should be reviewed for:
1. **Completeness:** All API endpoints and workflows covered
2. **Accuracy:** Proper mapping of requirements to components
3. **Feasibility:** Implementation approach is sound
4. **Scalability:** Architecture can grow with requirements

Once approved, this plan will be converted to implementation tasks using `generate-tasks.mdc`.
```

## Plan Generation Guidelines

### Specification Interpretation

When analyzing PRD, design specs, and REST API documentation:

#### Reading the PRD
- **Extract requirements** about what data is needed and when
- **Identify patterns** like "list views need minimal data, detail views need full data"
- **Translate to capabilities**: This becomes support for field selection, NOT "list view mode"
- **Example transformation:**
  - ❌ Don't create: `fetchApps({ viewMode: 'list' })`
  - ✓ Do create: `fetchApps({ fields: ['id', 'name'], depth: 0 })`

#### Reading Design Specs
- **Note which components** consume which data
- **Identify common data shapes** that appear across multiple screens
- **Don't create screen-specific functions**; create data-fetching functions with options that can serve multiple screens
- **Example:**
  - If mobile dashboard needs `[id, name, icon]` and desktop dashboard needs `[id, name, icon, lastModified, owner]`
  - ❌ Don't create: `fetchAppsForMobile()` and `fetchAppsForDesktop()`
  - ✓ Do create: `fetchApps({ fields: [...] })` where caller specifies needed fields

#### Reading REST API Specs
- **Understand available endpoints** and their capabilities
- **Note any batching, filtering, or field selection** the API already supports
- **Map API capabilities to middleware options** transparently
- **If the API has limitations**, document them but don't work around them with caller-specific logic
- **Example:**
  - If API supports `?fields=id,name,icon` parameter
  - Map this to middleware option: `{ fields: ['id', 'name', 'icon'] }`
  - Transform to API query string in implementation

### Comprehensive Analysis
- Read ALL provided API documentation files completely
- Extract every endpoint, workflow, and requirement
- Identify all dependencies and validation rules
- Map every error condition and recovery strategy

### Architecture Design
- Ensure workflow enforcement is built into the design
- Plan for data integrity at every level
- Design for UI framework agnostic integration
- Include comprehensive error handling

### Documentation Quality
- Use clear, specific language
- Include concrete examples where helpful
- Ensure compatibility with task generation
- Plan for junior developer implementation

### Validation Requirements
- Extract all validation rules from API documentation
- Include platform-specific requirements (iOS vs Android)
- Plan for cross-field validation
- Include business rule validation

## Target Audience

The generated plan should be suitable for:
- **Senior developers** reviewing architecture decisions and validating caller-agnostic design
- **Middleware developers** implementing behavior-parameterized, reusable components
- **Code reviewers** validating adherence to behavior-parameterized design principles
- **Junior developers** who will implement the tasks following the architectural patterns
- **Project managers** tracking implementation progress
- **QA engineers** understanding system behavior and testing option combinations

## Final Instructions

1. **Analyze ALL API documentation** thoroughly before beginning
2. **Create a complete architecture plan** that addresses every requirement
3. **Ensure the plan structure** matches the required format exactly
4. **ENFORCE Fliplet.API.request() usage** - All HTTP communication must use Fliplet.API.request()
5. **Include specific details** that can be converted to actionable tasks
6. **Plan for proper workflow enforcement** and data integrity
7. **Design for vanilla JavaScript** without module systems
8. **Prepare for task generation** by including implementation details
9. **ENFORCE behavior-parameterized design** - All middleware functions must accept behavioral options, never caller identity parameters
10. **VALIDATE against anti-patterns** - Explicitly check for and avoid caller-identification patterns, hidden branching, and ambiguous parameters
11. **DOCUMENT design rationale** - Explain capabilities in terms of behavioral needs, not specific UI contexts
12. **APPLY validation checklist** - Ensure every function design passes the Middleware Design Validation Checklist
