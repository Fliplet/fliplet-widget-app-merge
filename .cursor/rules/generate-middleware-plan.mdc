---
description: Generating Middleware Architecture Plans from REST API Documentation
globs:
alwaysApply: false
---
# Rule: Generating Middleware Architecture Plans from REST API Documentation

## Goal

To guide an AI assistant in analyzing existing documents including (but not limited to) PRD, design specs, REST API specs and creating a comprehensive middleware architecture plan that serves as the foundation for subsequent task generation and implementation. The plan ensures proper workflow enforcement, data integrity, and UI-agnostic design.

## Output

- **Format:** Markdown (`.md`)
- **Location:** `/tasks/`
- **Filename:** `middleware-plan-[project-name].md`
- **Purpose:** Comprehensive architecture plan ready for task generation

## Process

This rule uses a **progressive generation approach** to ensure thorough review at each major architectural decision point. The plan is generated in three phases, with user approval required between phases.

### Phase 1: Core Architecture & Design Principles (Foundation)

Generate the foundational architecture that defines how the middleware will be structured:

1. **Analyze API Documentation:** Read and thoroughly analyze all provided REST API documentation files
2. **Identify System Patterns:** Extract workflows, dependencies, data structures, and business rules
3. **Design Core Architecture Principles:** Define behavior-parameterized design philosophy, component hierarchy, and design patterns
4. **Generate Phase 1 Sections:**
   - Overview
   - System Architecture (Core Principles, Component Hierarchy, Middleware Design Principles)
   - Functional Requirements (high-level FRs)
   - Anti-Patterns to Avoid
   - Middleware Design Validation Checklist

**Output:** Present Phase 1 sections to the user with this message:

> "I have generated the core architecture and design principles for the middleware plan. This establishes the foundational patterns and principles that will guide all implementation.
>
> Please review:
> - Core architectural principles (behavior-parameterized design)
> - Component hierarchy and relationships
> - Middleware design patterns and anti-patterns
> - Design validation checklist
>
> **Ready to proceed with technical component specifications?** Respond with **'Go'** to continue to Phase 2."

**Wait for user confirmation before proceeding.**

---

### Phase 2: Technical Components & API Integration (Implementation Specs)

Once Phase 1 is approved, generate detailed technical specifications for all components:

5. **Design Component Architecture:** Define all classes, services, and controllers with detailed specifications
6. **Map API Integration:** Map API endpoints to service methods with behavioral options
7. **Plan Workflow Controllers:** Define workflow orchestration and state management
8. **Generate Phase 2 Sections:**
   - Technical Architecture (Core Foundation Classes, API Service Classes, Workflow Controller Classes, Supporting Infrastructure)
   - API Integration Mapping (Endpoint Groups, Workflow Sequences)
   - State Management Design
   - Validation Framework Design
   - Error Handling Strategy

**Output:** Present Phase 2 sections to the user with this message:

> "I have generated the detailed technical component specifications and API integration mapping.
>
> Please review:
> - Core classes and their responsibilities (ApiClient, StateManager, ValidationEngine, etc.)
> - API service method signatures with behavioral options
> - Workflow controller designs
> - State management schema and transitions
> - Validation rules and error handling strategies
>
> **Ready to proceed with implementation planning?** Respond with **'Go'** to continue to Phase 3."

**Wait for user confirmation before proceeding.**

---

### Phase 3: Implementation Details & Testing Strategy (Development Plan)

Once Phase 2 is approved, generate implementation details and development strategy:

9. **Plan Module System:** Determine appropriate module system (ES6, CommonJS, TypeScript, etc.) based on project stack
10. **Design File Structure:** Define complete directory structure and file organization
11. **Plan Testing Strategy:** Define test framework, coverage strategy, and test infrastructure
12. **Generate Phase 3 Sections:**
   - Implementation Considerations (Module System & Build Configuration, Development Approach)
   - Integration Patterns (Dependency Injection, Event System, Configuration Management)
   - Testing Foundations (Framework & Conventions, Setup Artifacts, Execution & CI)
   - Testing Strategy (detailed test approach)
   - File Structure Plan
   - Performance Considerations
   - Success Metrics

**Output:** Present Phase 3 sections to the user with this message:

> "I have completed the middleware architecture plan with implementation details and testing strategy.
>
> Phase 3 includes:
> - Module system configuration (if applicable to your stack)
> - Complete file structure
> - Testing framework setup and strategy
> - Integration patterns
> - Performance considerations
>
> The complete plan is now ready for review and can be used to generate implementation tasks using `generate-tasks.mdc`."

---

### Progressive Generation Benefits

This phased approach ensures:

✅ **Architectural Review First:** Core design patterns validated before detailed specs
✅ **Separation of Concerns:** Architecture, implementation, and testing reviewed independently
✅ **Iterative Refinement:** Early feedback prevents costly rework in later phases
✅ **Focused Discussion:** Each phase has clear scope for stakeholder review
✅ **Flexibility:** User can request changes at each checkpoint before proceeding

## Input Requirements

The AI should analyze the following from API documentation:

### API Documentation Files
- **API Endpoints:** Complete endpoint documentation with request/response schemas
- **API Flows:** Workflow sequences and dependencies
- **Sequence Diagrams:** Visual workflow representations
- **Implementation Guidelines:** Frontend integration patterns

### Key Analysis Areas
- **Workflow Dependencies:** Sequential steps that must be enforced
- **Data Validation:** Required fields, types, and business rules
- **Error Handling:** All error codes and recovery strategies
- **State Management:** Data persistence and state transitions
- **Authentication:** Security and authorization requirements

## Architecture Plan Structure

The generated plan must follow this exact structure for compatibility with `generate-tasks.mdc`:

```markdown
# Middleware Architecture Plan: [Project Name]

## Overview
[Brief description of the middleware system and its purpose]

## System Architecture

### Core Principles

**Foundation Philosophy:**
- **Behavior-Parameterized Design**: Middleware accepts parameters describing *what behavior is needed*, never *who is calling*
- **Caller-Agnostic Implementation**: No coupling to specific UI contexts, screens, or device types
- **Intent-Based Signatures**: Function parameters express behavioral options, not caller identity
- **Explicit Over Implicit**: All behavior must be explicitly requested through parameters, no magic defaults based on caller assumptions
- **Design-Time Awareness, Runtime Agnosticism**: Review PRD/specs to understand usage patterns, but never hardcode assumptions about callers

**Reference:** See `docs/middleware-dev-guidelines.md` for detailed philosophy and examples.

**Architecture Principles:**
- Workflow Enforcement: [How sequential processes are enforced]
- Data Integrity: [How data validation is implemented]
- State Management: [How application state is managed]
- Error Handling: [How errors are caught and handled]
- API Abstraction: [How REST APIs are wrapped with behavior-driven interfaces]

### Component Hierarchy
[Visual representation of class relationships and dependencies]

### Middleware Design Principles

#### Intent-Based Function Signatures

**DO:** Accept parameters that describe *what behavior is needed*
\`\`\`typescript
// ✓ Behavior-driven parameters
fetchApps({
  fields: ['id', 'name', 'lastModified'],
  filters: { organisationId: '123', isPublished: true },
  pagination: { page: 1, limit: 25 },
  sortBy: { field: 'lastModified', order: 'desc' },
  include: ['organisation', 'settings']
})
\`\`\`

**DON'T:** Accept parameters that identify *who is calling*
\`\`\`typescript
// ❌ Caller identification
fetchApps(orgId, callerType: 'dashboard' | 'mobile' | 'admin')
fetchApps(orgId, { isMobileView: true, isDashboard: false })
\`\`\`

#### API Response Transformation

**Driven by Options, Not Assumptions:**
- Transform REST API responses based on the `fields` parameter passed in
- If the REST API returns more data than requested, filter it according to options
- Construct API requests from behavioral parameters, not caller context
- Never create different response shapes based on assumed caller identity

**Example:**
\`\`\`javascript
// ✓ Transformation based on explicit options
function transformAppResponse(apiResponse, options = {}) {
  const { fields, include } = options;

  let result = apiResponse;

  // Filter fields if specified
  if (fields && fields.length > 0) {
    result = fields.reduce((obj, field) => {
      if (apiResponse[field] !== undefined) {
        obj[field] = apiResponse[field];
      }
      return obj;
    }, {});
  }

  // Include related resources if specified
  if (include && include.length > 0) {
    // Fetch and attach related resources
  }

  return result;
}
\`\`\`

#### State Management Integration

**Cache Keys Based on Request Parameters:**
- State structure should be **deterministic** based on data, not caller
- Cache keys must be derived from **request parameters**, not caller identity
- Provide cache control options: `{ cache: 'force-refresh' | 'cache-first' | 'network-only' }`

**Example:**
\`\`\`javascript
// ✓ Cache key from request parameters
function generateCacheKey(endpoint, options) {
  return `${endpoint}:${JSON.stringify(options)}`;
}

// ❌ Cache key from caller identity
function generateCacheKey(endpoint, callerType) {
  return `${endpoint}:${callerType}`;
}
\`\`\`

#### Data Fetching Patterns

**When PRD/design shows different UIs need different data:**
- ✓ Implement field selection: `{ fields: ['id', 'name', 'avatar'] }`
- ✓ Implement inclusion of relations: `{ include: ['profile', 'settings'] }`
- ✓ Implement depth control: `{ depth: 1 }` for shallow vs deep fetching
- ✓ Implement pagination: `{ page: 1, limit: 25 }`
- ❌ Don't implement: `{ clientType: 'dashboard' }` or `{ viewMode: 'mobile' }`

**Performance as Opt-In:**
- Let callers opt into performance features rather than guessing when to apply them
- Implement caching options that callers can enable
- Implement batch operation support where the REST API allows it
- Provide pagination capabilities without assuming when to use them

#### Critical Thinking for Design

Before implementing any middleware function, validate:
1. **Could this function serve a caller I haven't thought of yet?**
2. **Are my parameters describing *what to do* or *who is asking*?**
3. **If the UI completely changes tomorrow, would this function still make sense?**
4. **Can I explain every parameter's purpose without referring to specific screens or devices?**

If you answer "no" to any of these, reconsider the design.

## Functional Requirements

### FR1: [Requirement Name]
**Description:** [Clear description of what this component must do]
**Dependencies:** [What other components this depends on]
**Validation Rules:** [Data validation requirements]
**Error Handling:** [Specific error scenarios and responses]

### FR2: [Next Requirement]
[Continue for all major functional requirements]

## Technical Architecture

### Core Foundation Classes

#### BaseMiddleware
**Purpose:** [Foundation class responsibilities]
**Key Methods:** [Primary methods this class will provide]
**Dependencies:** [What this class depends on]

#### StateManager
**Purpose:** [State management responsibilities]
**State Schema:** [Structure of application state]
**Validation Rules:** [State transition validation]

#### ValidationEngine
**Purpose:** [Data validation responsibilities]
**Validation Types:** [Types of validation performed]
**Integration:** [How it integrates with other components]

### API Service Classes

#### ApiClient
**Purpose:** [HTTP communication responsibilities using Fliplet.API.request()]
**Features:** [Authentication, retry logic, error handling via Fliplet API]
**Configuration:** [How it wraps Fliplet.API.request() and handles responses]
**Implementation:** Must use Fliplet.API.request() as documented at https://developers.fliplet.com/API/core/api.html.

**CRITICAL IMPLEMENTATION REQUIREMENTS:**
1. **No baseUrl needed:** Fliplet.API.request() automatically uses `Fliplet.Env.get('apiUrl')` as the default base URL, returning 'https://api.fliplet.com/' for production and 'https://staging.api.fliplet.com/' for staging etc.
2. **Custom API URL:** Check `Fliplet.Navigate.query.apiUrl` and pass it as `{ apiUrl }` option to Fliplet.API.request() only when provided
3. **Custom Auth Token:** Check `Fliplet.Navigate.query.auth_token` and pass it as `{ headers: { 'Auth-token': auth_token } }` option
4. **URL handling:** Fliplet.API.request() expects base URL to end with trailing slash and endpoint to start without slash (e.g., apiUrl: 'https://api.fliplet.com/', url: 'v1/submissions')

**Example Implementation Pattern:**
\`\`\`javascript
// Constructor - no baseUrl needed
this.config = {
  timeout: 30000,
  retryAttempts: 3,
  retryDelay: 1000,
  // ... other config
};

// Check for overrides from Fliplet.Navigate.query
this.apiUrl = null; // Only set if custom apiUrl provided
this.authToken = null;

if (typeof Fliplet !== 'undefined' && Fliplet.Navigate && Fliplet.Navigate.query) {
  if (Fliplet.Navigate.query.apiUrl) {
    this.apiUrl = Fliplet.Navigate.query.apiUrl;
  }
  if (Fliplet.Navigate.query.auth_token) {
    this.authToken = Fliplet.Navigate.query.auth_token;
  }
}

// In request method
const requestConfig = {
  url: this.buildRequestUrl(endpoint, params), // Handles both cases
  method: method.toUpperCase(),
  headers: this.buildRequestHeaders(customHeaders)
};

// Add custom apiUrl only if provided
if (this.apiUrl) {
  requestConfig.apiUrl = this.apiUrl;
}

// buildRequestUrl method handles both cases:
// - No custom apiUrl: return 'v1/submissions' (Fliplet.API.request() adds base URL with trailing slash)
// - Custom apiUrl: return 'https://custom.api.com/v1/submissions' (full URL when custom apiUrl provided)
\`\`\`

#### [Domain]ApiService Classes
[For each major API domain, define:]
**Purpose:** [What API endpoints this service wraps]
**Methods:** [Key methods corresponding to endpoints using behavioral options]

**Method Design Guidelines:**
- Use **options objects** with descriptive, behavioral parameters
- Accept parameters describing what data/behavior is needed, not who is calling
- Example method signature:
  \`\`\`javascript
  fetchItems(id, options = {
    fields: [],        // Which data fields to return
    include: [],       // Related resources to include
    filters: {},       // Data filtering criteria
    pagination: {},    // Page number and limit
    sort: {},         // Sort field and order
    cache: 'default'  // Cache strategy
  })
  \`\`\`
- **Avoid** caller-identifying parameters like `callerType`, `isMobile`, `viewMode`
- **Avoid** implicit behavior based on internal logic or environment detection

**Validation:** [Request/response validation based on explicit parameters]
**Error Mapping:** [How API errors are transformed into consistent error objects]

### Workflow Controller Classes

#### WorkflowManager
**Purpose:** [Workflow orchestration responsibilities]
**Workflow Types:** [Different workflows it manages]
**Dependencies:** [How it enforces sequential execution]

#### [Process]Controller Classes
[For each major workflow, define:]
**Purpose:** [What business process this controls]
**Steps:** [Sequential steps in the workflow]

**Controller Design Guidelines:**
- Controllers orchestrate workflows using **behavioral configuration**, not caller context
- Accept options that control workflow behavior (validation depth, rollback strategy, notification preferences)
- Provide granular, compositional options over high-level "modes"
- Example:
  \`\`\`javascript
  executeWorkflow(workflowId, options = {
    validation: 'strict' | 'lenient',  // How to validate steps
    parallel: false,                    // Execute steps in parallel where possible
    rollbackOn: 'error' | 'failure',   // Rollback strategy
    notify: true,                       // Send progress notifications
    checkpoints: []                     // Steps where state is persisted
  })
  \`\`\`
- **Design for reusability** across different UI contexts
- If the UI completely changes, the controller should still be useful

**Validation:** [Prerequisites and data requirements based on workflow options]
**State Management:** [How workflow state is tracked using deterministic keys]

### Supporting Infrastructure

#### ErrorHandler
**Purpose:** [Error management responsibilities]
**Error Categories:** [Types of errors handled]
**Recovery Strategies:** [How errors are resolved]
**User Experience:** [How errors are presented to users]

#### DataMapper
**Purpose:** [Data transformation responsibilities]
**Transformations:** [Types of data transformation]
**Validation:** [Data integrity checks]

## API Integration Mapping

### Endpoint Groups
[Group related endpoints and map to service classes]

#### [Group Name] (Maps to [ServiceClass])
- **GET [endpoint]** → [method_name]: [purpose]
- **POST [endpoint]** → [method_name]: [purpose]
- **PUT [endpoint]** → [method_name]: [purpose]
- **DELETE [endpoint]** → [method_name]: [purpose]

### Workflow Sequences
[Map API flow documentation to controller classes]

#### [Workflow Name] (Maps to [ControllerClass])
**Steps:**
1. [Step name] → [API call] → [validation] → [state update]
2. [Step name] → [API call] → [validation] → [state update]
[Continue for all steps]

**Dependencies:** [Prerequisites that must be satisfied]
**Validation Points:** [Where data integrity is checked]
**Error Handling:** [How failures are managed]

## State Management Design

### State Schema
\`\`\`javascript
{
  workflows: {
    [workflowName]: {
      currentStep: string,
      progress: number,
      data: object,
      errors: array,
      isComplete: boolean,
      dependencies: array
    }
  },
  cache: {
    [apiEndpoint]: {
      data: object,
      timestamp: string,
      ttl: number
    }
  },
  user: {
    // User session data
  },
  config: {
    // Application configuration
  }
}
\`\`\`

### State Transitions
[Define valid state transitions and validation rules]

### Persistence Strategy
[How state is persisted across sessions]

## Validation Framework Design

### Validation Rules
[Extract all validation requirements from API documentation]

#### Field Validation
- **Required Fields:** [List all required fields by endpoint]
- **Data Types:** [Type validation requirements]
- **Format Validation:** [Pattern matching requirements]
- **Range Validation:** [Min/max values and lengths]

#### Business Rules
- **Cross-field Validation:** [Dependencies between fields]
- **Conditional Requirements:** [Platform-specific requirements]
- **Workflow Validation:** [Sequential step requirements]

### Error Messages
[Map all API error codes to user-friendly messages]

## Error Handling Strategy

### Error Categories
1. **Validation Errors:** [Client-side validation failures]
2. **API Errors:** [Server-side errors and responses]
3. **Network Errors:** [Connectivity and timeout issues]
4. **Business Logic Errors:** [Workflow and dependency failures]

### Recovery Strategies
[Define how each error category should be handled]

### User Experience
[How errors are presented and what actions users can take]

## Anti-Patterns to Avoid

Document these anti-patterns explicitly in the plan to guide implementation:

### Caller Identification
❌ **Never accept parameters that identify who is calling:**
\`\`\`javascript
// ❌ Bad: Caller identification
function fetchData(id, source: 'mobile' | 'web' | 'admin')
function fetchData(id, { isMobileView: true, isDashboard: false })
function fetchData(id, callerType)
\`\`\`

### Hidden Branching Logic
❌ **Never use implicit branching based on caller context:**
\`\`\`javascript
// ❌ Bad: Hidden branching
function fetchData(id) {
  if (someInternalCheck) { return minimalData; }
  return fullData;
}
\`\`\`

### Overloaded Boolean Flags
❌ **Never use ambiguous boolean parameters:**
\`\`\`javascript
// ❌ Bad: What does "fast" mean?
function fetchData(id, fast: boolean)
\`\`\`

### Magic Strings Without Clear Semantics
❌ **Never use mode strings without clear behavioral meaning:**
\`\`\`javascript
// ❌ Bad: What's the difference between these?
function fetchData(id, mode: 'quick' | 'full' | 'detailed')
\`\`\`

### Environmental Detection
❌ **Never detect caller context from environment:**
\`\`\`javascript
// ❌ Bad: Detecting device type
function fetchData(id) {
  if (window.innerWidth < 768) {
    return minimalData;
  }
  return fullData;
}
\`\`\`

### Proper Alternatives

✓ **Instead, use explicit behavioral options:**
\`\`\`javascript
// ✓ Good: Explicit behavioral parameters
function fetchData(id, options = {
  fields: [],        // What data to include
  depth: 1,          // How deep to fetch relations
  cache: true,       // Whether to use cache
  priority: 'normal' // Request priority
})
\`\`\`

## Integration Patterns

### Dependency Injection
[How components are wired together]

### Event System
[How components communicate via events]

### Configuration Management
[How the system is configured and initialized]

## Testing Foundations

### Framework & Conventions
- [Selected framework and rationale, e.g., Jest for vanilla JS]
- [Directory layout for tests, e.g., src/**/Class.test.js alongside implementation]
- [Coverage targets and thresholds]

### Setup Artifacts
- [Configuration files to include, e.g., jest.config.js, tests/setup.js]
- [npm scripts to add: "test", "test:watch", "test:coverage"]
- [Mocking strategy for Fliplet APIs (e.g., MSW or stubbed globals)]

### Execution & CI
- [Commands to run tests locally]
- [How tests are invoked in CI and required to pass before merges]

## File Structure Plan

\`\`\`
/src/middleware/
├── core/
│   ├── BaseMiddleware.js
│   ├── StateManager.js
│   ├── ValidationEngine.js
│   ├── ErrorHandler.js
│   └── DataMapper.js
├── api/
│   ├── ApiClient.js
│   ├── [List all planned API service files]
│   └── ...
├── controllers/
│   ├── WorkflowManager.js
│   ├── [List all planned controller files]
│   └── ...
├── config/
│   ├── endpoints.js
│   ├── validation-rules.js
│   ├── error-messages.js
│   └── workflows.js
└── middleware.js
\`\`\`

## Implementation Considerations

### Module System & Build Configuration

**APPLICABILITY:** These guidelines apply only to projects using **ES6 modules with Babel and Webpack**. If your project uses:
- Pure vanilla JavaScript without a build system
- TypeScript (which handles modules differently)
- Different bundlers (Rollup, esbuild, Vite, Parcel) with their own module handling
- CommonJS exclusively with Node.js
- Native ES6 modules without transpilation

...then these specific Babel + Webpack guidelines may not apply. Consult your build tool's documentation for module system configuration.

**CRITICAL (Babel + Webpack projects only):** Use pure ES6 modules throughout middleware. Never mix with CommonJS.

#### ES6 Module System Requirements (Babel + Webpack Context)

**Why Pure ES6 Modules in Babel + Webpack Projects?**

When using Babel with Webpack, ES6 modules should be used exclusively for the following reasons:

❌ **Problems with Mixed Module Systems:**
- **`.default` Wrapper Issues:** Babel transforming ES6 to CommonJS wraps exports in `.default` objects
- **Class Instantiation Failures:** EventEmitter and other classes fail with "is not a constructor" errors
- **Dual Export Conflicts:** Having both `export default` and `module.exports` creates conflicts
- **Build Errors:** Using `module.exports` in ES6 context triggers "ES Modules may not assign module.exports" errors
- **Unpredictable Behavior:** Different import patterns (`import` vs `require`) behave differently

✅ **Benefits of Pure ES6 Modules:**
- **Native Webpack Support:** Webpack 5 natively handles ES6 modules without transformation
- **No Wrapper Objects:** Clean imports without `.default` access patterns
- **Tree Shaking:** Better dead code elimination for smaller bundles
- **Future-Proof:** Standard modern JavaScript that works everywhere
- **Predictable Imports:** Consistent behavior across all imports

#### Babel Configuration (Babel + Webpack Projects)

**Note:** This configuration is specific to Babel + Webpack setups. If you're using a different build tool (Vite, Rollup, esbuild, etc.), consult that tool's documentation for module handling.

Configure Babel to preserve ES6 modules and let Webpack handle them natively:

**`.babelrc` - Required Configuration for Babel + Webpack**
```json
{
  "presets": [
    ["@babel/preset-env", {
      "modules": false
    }]
  ]
}
```

**Critical Setting:** `"modules": false` tells Babel NOT to transform ES6 modules to CommonJS. This is essential because:
- Allows Webpack to process ES6 modules natively
- Prevents `.default` wrapper issues
- Enables proper tree-shaking
- Avoids class instantiation errors

**What Happens Without This Setting:**
1. Babel transforms `export default MyClass` to `module.exports = { default: MyClass }`
2. Import becomes `import MyClass from './file'` but MyClass is actually `{ default: MyClass }`
3. `new MyClass()` fails because you're trying to instantiate an object, not a class
4. Must use `new MyClass.default()` which is incorrect and breaks everywhere

#### Correct Module Export Patterns

**✅ Correct: Pure ES6 Default Export**
```javascript
// src/middleware/core/ApiClient.js
class ApiClient {
  constructor(config) {
    this.config = config;
  }

  async get(endpoint, params) {
    // Implementation
  }
}

// ONLY ES6 export - no module.exports
export default ApiClient;
```

**✅ Correct: Pure ES6 Named Exports**
```javascript
// src/middleware/utils/validators.js
export function validateEmail(email) {
  // Implementation
}

export function validatePhone(phone) {
  // Implementation
}

export const VALIDATION_PATTERNS = {
  email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
  phone: /^\+?[\d\s-()]+$/
};
```

**✅ Correct: Mixed Default and Named Exports**
```javascript
// src/middleware/core/EventEmitter.js
class EventEmitter {
  // Implementation
}

export const EVENT_TYPES = {
  SUCCESS: 'success',
  ERROR: 'error'
};

export default EventEmitter;
```

**❌ Incorrect: Mixing ES6 and CommonJS**
```javascript
// DON'T DO THIS - causes .default wrapper issues
class ApiClient {
  // ...
}

export default ApiClient;
module.exports = ApiClient;  // ❌ Error: ES Modules may not assign module.exports
```

**❌ Incorrect: Pure CommonJS in ES6 Context**
```javascript
// DON'T DO THIS - breaks with ES6 module system
class ApiClient {
  // ...
}

module.exports = ApiClient;  // ❌ Error with ES6 modules enabled
module.exports.ApiClient = ApiClient;  // ❌ Error with ES6 modules enabled
```

**❌ Incorrect: Trying to Support Both Systems**
```javascript
// DON'T DO THIS - creates unpredictable behavior
class ApiClient {
  // ...
}

export default ApiClient;

// Trying to support CommonJS too
if (typeof module !== 'undefined' && module.exports) {
  module.exports = ApiClient;  // ❌ Causes conflicts and errors
}
```

#### Correct Import Patterns

**✅ Correct: Pure ES6 Imports**
```javascript
// Import default export
import ApiClient from './core/ApiClient.js';
import EventEmitter from './core/EventEmitter.js';

// Import named exports
import { validateEmail, validatePhone } from './utils/validators.js';

// Import default and named exports together
import EventEmitter, { EVENT_TYPES } from './core/EventEmitter.js';

// Import everything as namespace
import * as validators from './utils/validators.js';

// Use imported classes
const client = new ApiClient(config);
const emitter = new EventEmitter();
```

**❌ Incorrect: CommonJS require()**
```javascript
// DON'T DO THIS in ES6 module context
const ApiClient = require('./core/ApiClient.js');
const { validateEmail } = require('./utils/validators.js');

// These will fail or require .default access with mixed module systems
```

#### Webpack Configuration for ES6 Modules

Webpack 5 natively supports ES6 modules when Babel is configured correctly:

**`webpack.config.js`**
```javascript
module.exports = {
  mode: 'production', // or 'development'

  entry: './src/main.js',

  output: {
    filename: 'app.js',
    path: path.resolve(__dirname, 'dist')
  },

  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              ['@babel/preset-env', {
                modules: false  // CRITICAL: Let Webpack handle ES6 modules
              }]
            ]
          }
        }
      },
      {
        test: /\.vue$/,
        loader: 'vue-loader'
      }
    ]
  },

  resolve: {
    extensions: ['.js', '.vue', '.json'],
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  }
};
```

**Key Points:**
- Babel loader with `modules: false` lets Webpack process ES6 natively
- Webpack handles module resolution, bundling, and optimization
- Tree-shaking works properly with native ES6 modules
- No `.default` wrapper issues in final bundle

#### Global Namespace Exposure for Vue Integration (Vue Projects Only)

**APPLICABILITY:** This pattern applies only when integrating middleware with **Vue 3.x applications**. For other frameworks or vanilla JavaScript, use appropriate integration patterns for that context.

While using ES6 modules internally, expose middleware to global namespace for initialization:

**Pattern for Main Middleware Class:**
```javascript
// src/middleware/middleware.js
import ApiClient from './core/ApiClient.js';
import StateManager from './core/StateManager.js';
import EventEmitter from './core/EventEmitter.js';

class AppMergeMiddleware extends EventEmitter {
  constructor() {
    super();
    this.core = {
      apiClient: null,
      stateManager: null
    };
    this.api = {};
  }

  async initialize() {
    // Initialize API client
    this.core.apiClient = new ApiClient();

    // Initialize state manager
    this.core.stateManager = new StateManager();

    // Initialize API services
    // ...

    return this;
  }
}

// ES6 default export for module system
export default AppMergeMiddleware;

// Also expose to global namespace for Vue initialization
// This allows main.js to import and use it
if (typeof window !== 'undefined') {
  window.AppMergeMiddleware = AppMergeMiddleware;
}
```

**Integration with Vue:**
```javascript
// src/main.js
import { createApp } from 'vue';
import Application from './Application.vue';
import AppMergeMiddleware from './middleware/middleware.js';

// Use imported class (ES6 module import)
const middleware = new AppMergeMiddleware();

// Initialize middleware before mounting Vue
middleware.initialize().then(() => {
  const app = createApp(Application);

  // Provide middleware to all components via dependency injection
  app.provide('middleware', middleware);

  app.mount('#app-merge');
}).catch(error => {
  console.error('Failed to initialize middleware:', error);
});
```

#### File Structure for ES6 Modules

Organize middleware files using ES6 module structure:

```
/src/middleware/
├── core/
│   ├── ApiClient.js          # export default ApiClient
│   ├── StateManager.js       # export default StateManager
│   ├── EventEmitter.js       # export default EventEmitter
│   ├── ValidationEngine.js   # export default ValidationEngine
│   └── ErrorHandler.js       # export default ErrorHandler
├── api/
│   ├── AppsApiService.js     # export default AppsApiService
│   ├── DataSourcesApiService.js
│   └── ...
├── controllers/
│   ├── WorkflowManager.js    # export default WorkflowManager
│   └── ...
├── utils/
│   ├── validators.js         # export { validateX, validateY, ... }
│   ├── formatters.js         # export { formatDate, formatCurrency, ... }
│   └── helpers.js            # export { helperA, helperB, ... }
├── config/
│   ├── endpoints.js          # export const ENDPOINTS = { ... }
│   ├── constants.js          # export const CONSTANTS = { ... }
│   └── ...
└── middleware.js             # export default AppMergeMiddleware + window exposure
```

**Import Pattern in Main Middleware:**
```javascript
// src/middleware/middleware.js
import EventEmitter from './core/EventEmitter.js';
import ApiClient from './core/ApiClient.js';
import StateManager from './core/StateManager.js';
import ValidationEngine from './core/ValidationEngine.js';
import ErrorHandler from './core/ErrorHandler.js';

import AppsApiService from './api/AppsApiService.js';
import DataSourcesApiService from './api/DataSourcesApiService.js';

import WorkflowManager from './controllers/WorkflowManager.js';

import { ENDPOINTS } from './config/endpoints.js';
import { CONSTANTS } from './config/constants.js';

class AppMergeMiddleware extends EventEmitter {
  constructor() {
    super();
    // Initialize using imported classes
    this.core = {
      apiClient: new ApiClient(ENDPOINTS),
      stateManager: new StateManager(),
      validationEngine: new ValidationEngine(),
      errorHandler: new ErrorHandler()
    };
  }
}

export default AppMergeMiddleware;
```

#### Build Process Verification

After configuring ES6 modules, verify the build works correctly:

**1. Check Babel Configuration:**
```bash
# Verify .babelrc exists with correct settings
cat .babelrc
# Should show: { "presets": [["@babel/preset-env", { "modules": false }]] }
```

**2. Run Build:**
```bash
npm run build
```

**3. Verify No Errors:**
- No "is not a constructor" errors
- No "ES Modules may not assign module.exports" errors
- No `.default` access needed in bundled code

**4. Test Import/Export:**
```javascript
// In any middleware file, this should work:
import SomeClass from './SomeClass.js';
const instance = new SomeClass(); // Should work without .default
```

#### Common Migration Issues and Solutions

**Issue 1: "EventEmitter is not a constructor"**
- **Cause:** Babel transformed ES6 to CommonJS, creating `.default` wrapper
- **Solution:** Set `"modules": false` in `.babelrc`

**Issue 2: "ES Modules may not assign module.exports"**
- **Cause:** Mixing `export default` and `module.exports` in same file
- **Solution:** Remove all `module.exports` statements, use only ES6 exports

**Issue 3: "Cannot find module" errors**
- **Cause:** Incorrect import paths or missing file extensions
- **Solution:** Use explicit `.js` extensions in import paths

**Issue 4: ".default is undefined"**
- **Cause:** Babel transforming modules despite Webpack expecting native ES6
- **Solution:** Verify `"modules": false` is set in Babel config

### Development Approach
- **Module System:** Choose appropriate module system for your project:
  - **With build system (Babel + Webpack):** Pure ES6 imports/exports (see Module System section above for Babel configuration)
  - **With TypeScript:** Use ES6 modules with TypeScript's native handling
  - **With other bundlers (Vite, Rollup, etc.):** Follow that tool's module recommendations
  - **Without build system:** Use appropriate pattern (UMD, IIFE, or native ES6 if browser support allows)
- **Fliplet API Integration:** ALL HTTP requests must use Fliplet.API.request() (https://developers.fliplet.com/API/core/api.html)
- **Dependency Injection:** Constructor-based dependency injection (pattern depends on module system choice)
- **Event-Driven:** Event system for component communication
- **Self-Documenting:** Comprehensive JSDoc documentation

### Testing Strategy

**Caller-Agnostic Testing Principles:**
- **Test behavior under different option combinations**, not "caller types"
- **Verify determinism**: Same options always produce the same behavior
- **Test edge cases**: Empty options, maximum options, invalid combinations
- **No caller simulation**: Don't write tests that simulate different "mobile" vs "web" contexts
- **Example:**
  \`\`\`javascript
  // ✓ Good: Test different behavioral options
  test('fetchApps with minimal fields', () => {
    const result = fetchApps({ fields: ['id', 'name'] });
    expect(result).toHaveOnlyFields(['id', 'name']);
  });

  test('fetchApps with full fields', () => {
    const result = fetchApps({ fields: ['id', 'name', 'owner', 'settings'] });
    expect(result).toHaveOnlyFields(['id', 'name', 'owner', 'settings']);
  });

  // ❌ Bad: Test caller types
  test('fetchApps for mobile returns minimal data', () => {
    const result = fetchApps({ callerType: 'mobile' });
    // ...
  });
  \`\`\`

**Framework & Setup:**
- **Framework Detection (existing codebases):** Before planning tests, identify if a framework already exists by checking for files like `jest.config.*`, `vitest.config.*`, test directories (`__tests__`, `tests`, `*.test.js`), and `package.json` scripts (`test`). If present, conform to existing conventions (folders, scripts, matchers, setup files).
- **Bootstrapping (new projects):** If no framework is detected, the plan MUST include a dedicated "Testing Foundations" section that specifies:
  - Framework: Prefer Jest for vanilla JavaScript projects
  - Config files: `jest.config.js`, `tests/setup.js` (global stubs for `Fliplet`), and optional `tests/mocks/`
  - Scripts: add `"test": "jest"`, `"test:watch": "jest --watch"`, `"test:coverage": "jest --coverage"` to `package.json`
  - Test placement: colocate `*.test.js` files next to the code they verify
  - Minimum coverage thresholds and how to enforce them
  - How to mock Fliplet APIs (e.g., global `Fliplet` stubs or MSW when HTTP is required)

**Test Coverage:**
- **Unit Tests:** One test file per class, testing all option combinations
- **Integration Tests:** Workflow testing scenarios with different configurations
- **Mock Data:** Complete mock datasets representing various option states
- **Error Simulation:** Test all error conditions, ensuring consistent handling regardless of options

### Performance Considerations
- **Caching Strategy:** [How API responses will be cached]
- **State Optimization:** [How state updates will be optimized]
- **Memory Management:** [How memory usage will be controlled]

## Success Metrics

### Functional Success
- **Workflow Enforcement:** Users cannot skip required steps
- **Data Integrity:** Invalid data is caught before API calls
- **Error Recovery:** All error conditions have proper handling
- **State Consistency:** Application state remains valid

### Technical Success
- **API Abstraction:** UI code never directly calls REST APIs
- **Code Reusability:** Components can be reused across projects
- **Maintainability:** Clear separation of concerns and documentation
- **Testability:** All components have comprehensive test coverage

### Design Quality Success
- **Caller Agnosticism:** Middleware functions can serve any caller without modification
- **Parameter Clarity:** Every parameter describes behavior, not caller identity
- **Future-Proof Design:** Functions remain valid if UI completely changes
- **Self-Documenting:** Parameters are self-explanatory without referring to specific screens or devices
- **Behavioral Composition:** Complex behaviors can be achieved by combining simple options
- **Deterministic Behavior:** Same options always produce the same result

## Middleware Design Validation Checklist

Before finalizing the architecture plan, validate each middleware function design against these criteria:

### Caller Agnosticism Validation
- [ ] Could this function serve a caller I haven't thought of yet?
- [ ] Are parameters describing *what to do* or *who is asking*?
- [ ] If the UI completely changes tomorrow, would this function still make sense?
- [ ] Can I explain every parameter's purpose without referring to specific screens or devices?

### Parameter Design Validation
- [ ] Are all behaviors explicitly opt-in through parameters?
- [ ] Is there any hidden branching based on caller identity?
- [ ] Are options objects used instead of positional parameters?
- [ ] Do all parameters have clear, self-documenting names?
- [ ] Are there any boolean flags that could be replaced with explicit enums?

### State & Caching Validation
- [ ] Do cache keys depend only on request parameters, not caller context?
- [ ] Is state structure deterministic based on data, not caller?
- [ ] Are cache control options explicitly provided to callers?
- [ ] Can the same parameters produce different results based on hidden state?

### API Integration Validation
- [ ] Are REST API responses transformed based on explicit options?
- [ ] Is there any caller-specific response formatting?
- [ ] Are API errors mapped consistently regardless of caller?
- [ ] Can callers control API request behavior through options?

### Documentation Validation
- [ ] Is there documentation explaining the design rationale without mentioning specific UIs?
- [ ] Are usage examples provided showing different option combinations?
- [ ] Are all parameters documented with their behavioral purpose?
- [ ] Is it clear which options are mutually exclusive or interdependent?

**If any checkbox cannot be checked, the design must be reconsidered.**

## Next Steps

This architecture plan should be reviewed for:
1. **Completeness:** All API endpoints and workflows covered
2. **Accuracy:** Proper mapping of requirements to components
3. **Feasibility:** Implementation approach is sound
4. **Scalability:** Architecture can grow with requirements

Once approved, this plan will be converted to implementation tasks using `generate-tasks.mdc`.
```

## Plan Generation Guidelines

### Specification Interpretation

When analyzing PRD, design specs, and REST API documentation:

#### Reading the PRD
- **Extract requirements** about what data is needed and when
- **Identify patterns** like "list views need minimal data, detail views need full data"
- **Translate to capabilities**: This becomes support for field selection, NOT "list view mode"
- **Example transformation:**
  - ❌ Don't create: `fetchApps({ viewMode: 'list' })`
  - ✓ Do create: `fetchApps({ fields: ['id', 'name'], depth: 0 })`

#### Reading Design Specs
- **Note which components** consume which data
- **Identify common data shapes** that appear across multiple screens
- **Don't create screen-specific functions**; create data-fetching functions with options that can serve multiple screens
- **Example:**
  - If mobile dashboard needs `[id, name, icon]` and desktop dashboard needs `[id, name, icon, lastModified, owner]`
  - ❌ Don't create: `fetchAppsForMobile()` and `fetchAppsForDesktop()`
  - ✓ Do create: `fetchApps({ fields: [...] })` where caller specifies needed fields

#### Reading REST API Specs
- **Understand available endpoints** and their capabilities
- **Note any batching, filtering, or field selection** the API already supports
- **Map API capabilities to middleware options** transparently
- **If the API has limitations**, document them but don't work around them with caller-specific logic
- **Example:**
  - If API supports `?fields=id,name,icon` parameter
  - Map this to middleware option: `{ fields: ['id', 'name', 'icon'] }`
  - Transform to API query string in implementation

### Comprehensive Analysis
- Read ALL provided API documentation files completely
- Extract every endpoint, workflow, and requirement
- Identify all dependencies and validation rules
- Map every error condition and recovery strategy

### Architecture Design
- Ensure workflow enforcement is built into the design
- Plan for data integrity at every level
- Design for UI framework agnostic integration
- Include comprehensive error handling

### Documentation Quality
- Use clear, specific language
- Include concrete examples where helpful
- Ensure compatibility with task generation
- Plan for junior developer implementation

### Validation Requirements
- Extract all validation rules from API documentation
- Include platform-specific requirements (iOS vs Android)
- Plan for cross-field validation
- Include business rule validation

## Target Audience

The generated plan should be suitable for:
- **Senior developers** reviewing architecture decisions and validating caller-agnostic design
- **Middleware developers** implementing behavior-parameterized, reusable components
- **Code reviewers** validating adherence to behavior-parameterized design principles
- **Junior developers** who will implement the tasks following the architectural patterns
- **Project managers** tracking implementation progress
- **QA engineers** understanding system behavior and testing option combinations

## Final Instructions

1. **Analyze ALL API documentation** thoroughly before beginning
2. **Create a complete architecture plan** that addresses every requirement
3. **Ensure the plan structure** matches the required format exactly
4. **ENFORCE Fliplet.API.request() usage** - All HTTP communication must use Fliplet.API.request()
5. **Include specific details** that can be converted to actionable tasks
6. **Plan for proper workflow enforcement** and data integrity
7. **Choose appropriate module system** - Determine if project uses ES6 modules, CommonJS, TypeScript, or no build system
8. **Apply module system guidelines** (Babel + Webpack projects only) - Follow ES6 module patterns in "Module System & Build Configuration" section
9. **Prepare for task generation** by including implementation details
10. **ENFORCE behavior-parameterized design** - All middleware functions must accept behavioral options, never caller identity parameters
11. **VALIDATE against anti-patterns** - Explicitly check for and avoid caller-identification patterns, hidden branching, and ambiguous parameters
12. **DOCUMENT design rationale** - Explain capabilities in terms of behavioral needs, not specific UI contexts
13. **APPLY validation checklist** - Ensure every function design passes the Middleware Design Validation Checklist
