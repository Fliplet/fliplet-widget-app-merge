---
description: Generating Comprehensive UI/UX Plans from Middleware Architecture
globs:
alwaysApply: false
---
# Rule: Generating Comprehensive UI/UX Plans from Middleware Architecture

## Goal

To guide an AI assistant in analyzing existing documents including (but not limited to) PRD, design specs, REST API specs, middleware architecture and creating a comprehensive UI/UX plan that enables Product Managers and Designers to review and ensure high-quality and responsive user interfaces that meet the requirements. The plan serves as the foundation for subsequent task generation and implementation while maintaining Fliplet's branding guidelines and accessibility standards.

## Design Philosophy

**Create beautiful, production-worthy interfaces—not cookie-cutter designs.**

All UI plans should result in fully-featured, polished webpages ready for production use. Prioritize:

- **Visual Excellence:** Modern, aesthetically pleasing designs with attention to spacing, typography, and visual hierarchy
- **User Delight:** Thoughtful interactions, smooth transitions, and intuitive user flows
- **Production Quality:** Robust error handling, loading states, and edge case coverage
- **Brand Consistency:** Cohesive design language aligned with Fliplet's design principles
- **Accessibility First:** WCAG 2.1 AA compliance built in from the start, not added later

## Output

- **Format:** Markdown (`.md`)
- **Location:** `/tasks/`
- **Filename:** `ui-plan-[project-name].md`
- **Purpose:** Comprehensive UI/UX plan ready for review and task generation

## Important Technical Context

### Vue.js Version

This rule generates UI plans for **Vue.js v3.5.13** projects. All component syntax, lifecycle hooks, and API usage should be compatible with Vue 3.5.13.

### Widget Context

Before generating the UI plan, clarify with the user whether the UI is being built for:
- **Interface Context:** Configuration UI shown in Fliplet Studio (widget settings)
- **Build Context:** Runtime UI shown to end users in the published app

### Essential Documentation References

```yaml
# MUST READ - Include these in your context window

- url: https://api.fliplet.com/v1/widgets/assets
  why: Complete list of available assets (CSS/JS libraries) that widgets can use
  critical: Check available versions, latest version and dependencies before suggesting libraries

- url: https://developers.fliplet.com/Dependencies-and-assets.html
  why: Explains how to properly include assets and manage dependencies in widgets
  section: Focus on "Declaring dependencies" and "Loading assets dynamically"

- url: https://developers.fliplet.com/Introduction.html
  why: Core concepts for building Fliplet widgets (components)
  critical: Understand the widget lifecycle and build/interface contexts

- file: widget.json
  why: Widget configuration file that defines dependencies and settings
  critical: Check existing dependencies before suggesting new ones

- doc: /docs/*-prd.md
  why: Product requirements defining business goals, user journeys, and acceptance criteria
  critical: Align UI behaviours, content hierarchy, and success metrics with the PRD

- doc: /docs/*design-spec*.md
  why: Detailed UI layouts, component behaviours, and interaction nuances
  critical: Ensure the plan reflects prescribed layouts, states, and interaction rules

- doc: /tasks/middleware-plan-[project-name].md
  why: The middleware architecture this UI plan must integrate with
  critical: Understand available services, data flows, and state management
```

## Process

1. **Clarify Context:** Determine if building for interface or build context
2. **Interpret Product & Design Docs:** Absorb PRD and design specifications to understand business goals, target personas, canonical screens, and prescribed interactions
3. **Analyze Middleware Architecture:** Read and understand the existing middleware plan and implementation
4. **Check Available Assets:** Review Fliplet's asset library for compatible dependencies
5. **Identify UI Requirements:** Extract user workflows, data displays, interactions, and contextual warnings called out in product/design docs
6. **Design Component Architecture:** Create reusable Vue.js 3.5.13 components that integrate with middleware and map to documented UI constructs
7. **Plan Responsive Layouts:** Design mobile-first responsive interfaces
8. **Define Customization Framework:** Plan theming and branding customization
9. **Document Accessibility:** Ensure WCAG 2.1 AA compliance throughout
10. **Generate Plan Document:** Create structured markdown plan ready for review and task generation

## Input Requirements

The AI should analyze the following:

### Product & Design Source Materials
- **Product Requirements:** `/docs/*-prd.md` — define business outcomes, user journeys, acceptance criteria
- **Design Specifications:** `/docs/*design-spec*.md` — prescribe layouts, state visuals, component hierarchies, interaction rules

### Middleware Documentation
- **Architecture Plan:** `/tasks/middleware-plan-[project-name].md`
- **Implementation Files:** `/src/middleware/` directory structure
- **API Service Interfaces:** Available methods and data structures
- **Workflow Controllers:** User interaction sequences
- **State Management:** Data available for UI display

### Key Analysis Areas
- **User Workflows:** Sequential steps users must complete, aligned with PRD journeys
- **Data Presentation:** Information that needs to be displayed, using design-spec layout guidance
- **User Actions:** Buttons, forms, and interactions required; include locking, validation, and warnings
- **Error States:** How errors should be presented to users, referencing design copy and fallback patterns
- **Loading & Countdown States:** Progressive disclosure, skeleton screens, timers, and lock countdowns
- **Accessibility:** Keyboard navigation, screen reader support, focus management detailed in specs

## UI/UX Plan Structure

The generated plan must follow this exact structure for compatibility with `generate-tasks.mdc` and comprehensive UX review:

```markdown
# UI/UX Plan: [Project Name]

## Overview
[Brief description of the UI system, its purpose, and target users]

### Source Alignment
- **Primary PRD References:** Summarize key feature goals, guardrails, and acceptance criteria informing the UI plan
- **Design Spec References:** Note canonical screen layouts, component patterns, and interaction details guiding the UI

## Technical Stack

### Framework
- **Vue.js Version:** 3.5.13
- **Component API:** Vue Options API (for compatibility)
- **Build Context:** [interface|build] - Specify which context this UI serves

### Styling Framework
- **Tailwind CSS:** Modern utility-first CSS framework
  - Installed via `package.json` as a dev dependency
  - Compiled through Gulp and Webpack build process
  - Configured via `tailwind.config.js`
  - PostCSS processing for production optimization
  - **DO NOT** rely on Fliplet's asset library for Tailwind—it's compiled into the widget's CSS bundle

### Icon Library
- **lucide-vue-next:** Beautiful, consistent icon set for Vue 3
  - Installed via `package.json`
  - Provides tree-shakeable, customizable SVG icons
  - Use for all icons, logos, and visual indicators
  - **DO NOT** install other icon packages unless absolutely necessary

### Available Fliplet Dependencies
- **fliplet-core:** Core Fliplet functionality (always required)
- **font-awesome:** Available from Fliplet assets (v4.7.0) - use only if lucide-vue-next doesn't have needed icons
- **fliplet-icons:** Fliplet's custom icon font - use only for Fliplet-specific UI elements

### Dependencies to Avoid
- **fliplet-studio-ui:** Not needed when using Tailwind CSS
- **bootstrap-css:** Not needed when using Tailwind CSS
- **Additional UI frameworks:** Tailwind CSS is sufficient for all styling needs

## Design Principles

### Core Principles
- **Responsive Design:** Mobile-first approach with fluid layouts
- **Accessibility:** WCAG 2.1 AA compliance throughout
- **Brand Flexibility:** Customizable theming system
- **User Experience:** Clear navigation and intuitive interactions
- **Performance:** Optimized loading and smooth transitions

### Design System Integration
- **Tailwind CSS Utility Classes:** Use Tailwind's utility-first approach for all styling
- **Custom Components:** Build reusable Vue components with Tailwind classes
- **Design Tokens:** Configure Tailwind's theme to match Fliplet brand colors and spacing
- **Component Variants:** Use Tailwind's @apply directive sparingly for complex, repeated patterns only

## User Journey Mapping

### Primary User Flow: [Flow Name]
**User Goal:** [What the user wants to achieve]
**Entry Point:** [How users access this flow]
**Success Criteria:** [How users know they've succeeded]
**Referenced States:** [Enumerate relevant design-spec states/screens powering this flow]
**PRD Alignment:** [Link behavior back to PRD requirements]

**Steps:**
1. **[Step Name]**
   - User Action: [What the user does]
   - System Response: [How the UI responds; cite design-spec interactions]
   - Data Displayed: [Information shown; reference design layouts]
   - Possible Errors: [Error states and messages; include PRD acceptance criteria]

2. **[Next Step]**
   [Continue for all steps]

### Secondary User Flows
[Document additional user journeys as needed]

## State-Oriented UX Specifications

### UI State Matrix

Use state specifications to clearly outline different states/screens/pages, enabling thorough UX review and comprehensive testing.

> **Instruction:** Enumerate every canonical state captured in the design specification (e.g., dashboards, step-based flows, progress overlays) and ensure each has a corresponding entry below. Where the PRD defines business rules or acceptance criteria for a state, capture those within the relevant fields.

#### State Template

**[State Name]**

- **Entry Triggers:** How do we get here? (events, user actions, preconditions)
- **Design References:** Cite relevant design-spec sections or figures guiding layout/interactions
- **Visibility/Data:** Exactly what's on screen; data freshness rules and loading behavior
- **Allowed Actions:** Available buttons/gestures/menu items; preconditions for each; expected outcomes
- **Forbidden Actions (and Why):** What's disabled/hidden and rationale; how restrictions are communicated
- **System Feedback:** Loading indicators, progress bars, validation messages, toasts, banners (align with design copy)
- **Empty/Error/Offline Variants:** Copy, visuals, retry logic for each edge case; validate against PRD acceptance criteria
- **Permissions/Entitlements:** Role-based access, ownership rules, feature flags
- **Analytics:** Event names, properties, success metrics tracked in this state
- **Transitions:** Which next states are reachable and their triggers

#### Example State Specification

**Dashboard**

- **Entry Triggers:** User navigates to dashboard, page refresh, session timeout recovery
- **Visibility/Data:** Skeleton layout showing page structure, loading spinner in data areas
- **Allowed Actions:** Navigate away via main menu, cancel loading (if applicable)
- **Forbidden Actions (and Why):** No data actions available - buttons disabled with loading states
- **System Feedback:** Progress indicator, "Loading dashboard data..." message
- **Loading/Empty/Error/Offline Variants:** (e.g.)
  - Network error: "Unable to load dashboard. Check connection and try again"
  - Timeout: "Dashboard is taking longer than usual to load. Please wait or refresh"
- **Permissions/Entitlements:** Must have authenticated session and dashboard access role
- **Analytics:** `dashboard_load_started`, `dashboard_load_duration`, `dashboard_load_error`
- **Transitions:** → Dashboard Loaded (success), → Error State (failure), → Login (auth expired)

### State Transition Matrix

Create a matrix (rows = high-level application states, columns = user actions) to identify interaction gaps and valid transitions between major application areas:

> **Instruction:** Use the canonical states extracted from the design specification as matrix rows. Actions should reflect real interactions captured in PRD/design docs (e.g., lock extension, conflict resolution, audit-log access). Highlight restricted transitions mandated by product requirements.

| State / Action | Create New | Edit Existing | Submit | View Details | Delete | Navigate |
|---|---|---|---|---|---|---|
| **Planning Dashboard** | ✅ New Initiative | ✅ Edit Selected | ❌ Not Applicable | ✅ View Item | ✅ Archive Item | ✅ All Sections |
| **Work Item Drafting** | ✅ Draft Work Item | ✅ Edit Fields | ✅ Submit for Review | ✅ Preview Draft | ❌ Restricted | ⚠️ Confirm Exit |
| **Review & Approval** | ❌ Review Only | ✅ Request Changes | ✅ Approve Submission | ✅ View Submission | ❌ Restricted | ✅ Back to Dashboard |
| **Deployment Scheduling** | ❌ In Progress | ✅ Update Schedule | ✅ Confirm Release | ✅ View Schedule | ❌ Restricted | ⚠️ Unsaved Changes |
| **Audit & Reporting** | ❌ Read Only | ❌ Read Only | ❌ Not Applicable | ✅ View History | ❌ Restricted | ✅ Back to Dashboard |

## Product Analytics & Audit Logging

Define analytics events and audit logging from a Product perspective to measure success metrics, user behavior, and system usage. This complements engineering's system performance logging.

### Analytics Strategy

#### Product Success Metrics
Document what the Product team considers success for this feature. Reference the PRD to ensure coverage of core KPIs, guardrails, and business outcomes:

- **Primary Success Metrics:** Key performance indicators that define feature success
- **User Engagement Metrics:** How users interact with the feature over time
- **Business Impact Metrics:** Revenue, conversion, or operational efficiency gains
- **User Experience Metrics:** Task completion rates, user satisfaction, error rates

#### Analytics Event Categories

**User Journey Events**
- **Entry Points:** How users discover and access the feature
- **Navigation Events:** Movement through the application workflow
- **Completion Events:** Successful task completion and outcomes
- **Abandonment Events:** Where users drop off and why (include PRD-defined failure thresholds)

**Feature Usage Events**
- **Feature Discovery:** When users find and explore new capabilities
- **Feature Adoption:** First-time usage and ongoing engagement
- **Feature Mastery:** Advanced usage patterns and power user behaviors; align with PRD adoption milestones
- **Feature Feedback:** User satisfaction and feature improvement requests

**Business Process Events**
- **Workflow Initiation:** When business processes start
- **Process Milestones:** Key steps in business workflows
- **Process Completion:** Successful business outcomes
- **Process Optimization:** Efficiency improvements and bottlenecks tied to PRD metrics (e.g., merge duration, conflict resolution rate)

### Analytics Implementation Plan

#### Fliplet App Analytics Events

Use `Fliplet.App.Analytics.event()` for user behavior analytics visible in App Analytics dashboard:

\`\`\`javascript
// Example: Track workflow completion
Fliplet.App.Analytics.event({
  category: 'workflow_console',
  action: 'process_completed',
  label: 'Launch Checklist',
  value: 1 // Optional numeric value
});

// Example: Track feature usage
Fliplet.App.Analytics.event({
  category: 'ui_interaction',
  action: 'button_clicked',
  label: 'Export Summary Report'
});

// Example: Track user journey milestone
Fliplet.App.Analytics.event({
  category: 'process_journey',
  action: 'milestone_reached',
  label: 'First Process Completed'
});
\`\`\`

#### Fliplet App Logs for Audit Trail

Use `Fliplet.App.Logs.create()` for audit logs visible to organization admins:

\`\`\`javascript
// Example: Log data modification (scope only, no detailed values)
Fliplet.App.Logs.create({
  action: 'Record metadata updated',
  entity_id: 'record_123',
  modified_fields: ['title', 'description', 'status'],
  timestamp: new Date().toISOString()
}, 'record.metadata.modified');

// Example: Log sensitive actions
Fliplet.App.Logs.create({
  action: 'Workflow transitioned to Approved',
  entity_id: 'record_123',
  context: 'Operations Review',
  outcome: 'approved',
  timestamp: new Date().toISOString()
}, 'workflow.transition.completed');

// Example: Log permission changes (scope only)
Fliplet.App.Logs.create({
  action: 'User role updated',
  target_user_id: 'user_789',
  entity_scope: 'workspace_123',
  timestamp: new Date().toISOString()
}, 'user.permissions.changed');
\`\`\`

#### User Interaction Analytics

Track actual user interactions and actions using Fliplet Analytics Events:

**User Actions**
\`\`\`javascript
// When user clicks a button
Fliplet.App.Analytics.event({
  category: 'user_action',
  action: 'button_clicked',
  label: 'Submit for Approval'
});

// When user navigates to a section
Fliplet.App.Analytics.event({
  category: 'navigation',
  action: 'section_opened',
  label: 'Review Hub'
});

// When user completes a form
Fliplet.App.Analytics.event({
  category: 'form_interaction',
  action: 'form_submitted',
  label: 'Workflow Intake Form'
});
\`\`\`

**Critical Actions (Analytics + Audit Log)**
\`\`\`javascript
// User performs critical action - track engagement + log for audit
Fliplet.App.Analytics.event({
  category: 'critical_action',
  action: 'workflow_closed',
  label: 'Operations Release',
  value: 1
});

// Log the business outcome for admin review
Fliplet.App.Logs.create({
  action: 'Workflow closed with Release',
  context: 'Operations Release',
  timestamp: new Date().toISOString()
}, 'workflow.closed');
\`\`\`

**System States (Audit Log Only)**
\`\`\`javascript
// System states like errors, loading timeouts should only be logged for admin review
// DO NOT track these as analytics events since they're not user interactions

// Log system errors for troubleshooting
Fliplet.App.Logs.create({
  action: 'Network timeout during workflow update',
  error_type: 'network_timeout',
  timestamp: new Date().toISOString()
}, 'system.error');
\`\`\`

### Audit Logging Requirements

#### Compliance and Security Logging
Events that need to be logged for audit trails and compliance:

- **Data Access Events:** When users view sensitive information
- **Data Modification Events:** When users change system data
- **Permission Changes:** When user roles or access levels change
- **Configuration Changes:** When system settings are modified
- **Export Events:** When data is downloaded or exported
- **Import Events:** When external data is brought into the system

#### Business Process Audit Trail
Important business events that need permanent records:

- **Approval Workflows:** Who approved what and when
- **Financial Transactions:** Any monetary operations or calculations
- **Regulatory Compliance:** Events required for industry regulations
- **Data Retention:** Events related to data lifecycle management

### Analytics Integration with UI Components

#### Component-Level Event Tracking

Each UI component should define its analytics events:

\`\`\`javascript
// Example component analytics integration
const ComponentAnalytics = {
  // Form component events
  FormSubmission: {
    event: 'form_submitted',
    required_properties: ['form_type', 'validation_errors', 'completion_time'],
    success_metric: 'form_completion_rate'
  },

  // Table component events
  DataTableInteraction: {
    event: 'table_action_performed',
    required_properties: ['action_type', 'row_count', 'filter_applied'],
    success_metric: 'data_discoverability'
  },

  // Navigation component events
  NavigationUsage: {
    event: 'navigation_item_clicked',
    required_properties: ['destination', 'source_page', 'user_intent'],
    success_metric: 'navigation_efficiency'
  }
};
\`\`\`

#### User Experience Analytics

Track user experience quality metrics:

- **Task Efficiency:** Time to complete common tasks
- **Error Rates:** Frequency and types of user errors
- **Help Usage:** When users need assistance or documentation
- **Feature Discovery:** How users learn about new capabilities
- **Customization Usage:** How users personalize their experience

### Analytics Success Measurement

#### Key Performance Indicators (KPIs)
- **Feature Adoption Rate:** Percentage of eligible users who use the feature
- **Task Success Rate:** Percentage of successful task completions
- **User Retention Rate:** Users who return to use the feature repeatedly
- **Time to Value:** How quickly users achieve their goals
- **User Satisfaction Score:** Direct feedback from users about the experience

#### Reporting and Dashboards
- **Real-time Monitoring:** Live dashboard for critical metrics
- **Weekly Business Reviews:** Summary reports for stakeholders
- **Monthly Deep Dives:** Detailed analysis of user behavior patterns
- **Quarterly Strategy Reviews:** Long-term trend analysis and planning

### Privacy and Data Protection

#### Data Collection Guidelines
- **Minimal Data Principle:** Only collect data necessary for defined success metrics
- **User Consent:** Clear communication about what data is collected and why
- **Data Anonymization:** Remove personally identifiable information where possible
- **Retention Policies:** Define how long analytics data is stored

#### GDPR and Privacy Compliance
- **Right to Delete:** Ability to remove user data from analytics systems
- **Data Portability:** Export user's analytics data in readable format
- **Consent Management:** Track and manage user consent for different data types
- **Privacy by Design:** Build privacy considerations into analytics architecture

## Component Architecture

### Layout Components

#### AppShell
**Purpose:** Main application wrapper providing consistent structure
**Features:**
- Responsive navigation
- Branding area
- Content container
- Footer information

**Props:**
\`\`\`javascript
{
  branding: Object,     // Logo, colors, typography
  navigation: Array,    // Menu items and structure
  user: Object,        // Current user information
  showFooter: Boolean  // Toggle footer visibility
}
\`\`\`

#### NavigationHeader
**Purpose:** Primary navigation and branding display
**Responsive Behavior:**
- Desktop: Horizontal navigation bar
- Tablet: Condensed navigation
- Mobile: Hamburger menu with slide-out drawer
- **Design References:** [Map to design spec sections defining header layout, progress indicators, lock warnings]
- **PRD Alignment:** [Summarize responsibilities tied to product requirements]

### Page Components

#### [PageName]View (Map to design-spec page/state names)
**Purpose:** [What this page displays and manages]
**Design References:** [Call out the design-spec section that defines layout, components, warnings]
**PRD Alignment:** [Tie page responsibilities back to product requirements]
**Data Requirements:** [What middleware data it consumes]
**User Actions:** [Primary interactions available]
**States:**
- Loading: [How loading is indicated; include skeleton/timer guidance from design]
- Empty: [What shows when no data; cite design copy]
- Error: [How errors are displayed; include PRD acceptance messaging]
- Success: [Success state appearance]

### Form Components

#### [FormName]Form
**Purpose:** [What data this form collects]
**Design References:** [Specify design-spec section showing field arrangement, helper text, validation]
**Fields:** [List all form fields with types]
**Validation:** [Client-side validation rules; incorporate PRD acceptance criteria and design error messaging]
**Submission:** [How form interacts with middleware]

### UI Components

#### DataTable (Reference design-spec tab/table patterns)
**Purpose:** Display tabular data with sorting and filtering
**Design References:** [Tie back to table layouts, column configurations, and nested interactions described in design spec]
**Features:**
- Responsive table design
- Column sorting
- Search/filter functionality
- Pagination
- Row actions
- Nested rows / association indicators (if specified)
- Selection/locking indicators (if applicable in design spec)

#### StatusIndicator
**Purpose:** Show workflow progress and status
**States:** [Different status types and their visual representation]

#### ActionButton
**Purpose:** Primary action triggers with loading states
**Variants:** Primary, Secondary, Danger, Success

### Feedback Components

#### NotificationToast
**Purpose:** Temporary feedback messages
**Types:** Success, Warning, Error, Info
**Behavior:** Auto-dismiss with manual close option
- **Design References:** [Link to design-spec messaging patterns and copy]
- **PRD Alignment:** [Ensure warnings/success align with product acceptance criteria]

#### ModalDialog
**Purpose:** Confirmations and focused interactions
**Variants:** Confirm, Alert, Custom content
- **Design References:** [Specify modal layouts and content flows from design spec]
- **PRD Alignment:** [Tie usage to business rules requiring confirmation]

## Responsive Design Strategy

### Breakpoints
\`\`\`scss
$breakpoints: (
  'mobile': 320px,    // Base mobile design
  'tablet': 768px,    // Tablet portrait
  'desktop': 1024px,  // Desktop and larger
  'wide': 1440px     // Wide screens
);
\`\`\`

### Layout Patterns

#### Mobile First
- Single column layouts
- Stacked navigation
- Full-width forms
- Collapsed tables to cards

#### Tablet Adaptations
- Two-column layouts where appropriate
- Side navigation option
- Expanded table views
- Modal dialogs instead of full-screen

#### Desktop Enhancements
- Multi-column dashboards
- Persistent navigation
- Side-by-side comparisons
- Advanced filtering panels

### Tailwind Responsive Classes

Use Tailwind's responsive prefixes for all breakpoint-specific styling:

\`\`\`vue
<template>
  <!-- Mobile-first: stack vertically, then side-by-side on tablet+ -->
  <div class="flex flex-col md:flex-row gap-4">
    <!-- Content -->
  </div>

  <!-- Hide on mobile, show on desktop -->
  <nav class="hidden lg:block">
    <!-- Desktop navigation -->
  </nav>

  <!-- Show on mobile, hide on desktop -->
  <button class="lg:hidden">
    <!-- Mobile menu button -->
  </button>

  <!-- Responsive padding and text sizes -->
  <div class="px-4 md:px-6 lg:px-8">
    <h1 class="text-xl md:text-2xl lg:text-3xl">
      Responsive Heading
    </h1>
  </div>
</template>
\`\`\`

**Breakpoint Mapping:**
- Default: Mobile (0px+) - no prefix
- `sm:`: 640px and up
- `md:`: 768px and up (tablet)
- `lg:`: 1024px and up (desktop)
- `xl:`: 1280px and up (wide desktop)

## Theming & Customization

### Tailwind Configuration
Configure Tailwind theme in `tailwind.config.js` to match Fliplet branding:

\`\`\`javascript
// tailwind.config.js
module.exports = {
  content: [
    './src/**/*.{vue,js,html}',
    './build.html'
  ],
  theme: {
    extend: {
      colors: {
        // Fliplet Brand Colors
        primary: {
          DEFAULT: '#00abd1',
          50: '#e6f7fb',
          100: '#b3e7f4',
          500: '#00abd1',
          600: '#0095b8',
          700: '#00809f',
        },
        secondary: {
          DEFAULT: '#eae9ec',
          50: '#fafafa',
          100: '#eae9ec',
          500: '#d4d3d8',
          700: '#a8a7af',
        },
        accent: {
          DEFAULT: '#36344c',
          500: '#36344c',
          700: '#242333',
        },
        // Semantic Colors
        success: '#19cd9d',
        warning: '#ed9119',
        error: '#e03629',
        info: '#413e5b',
      },
      fontFamily: {
        sans: ['Open Sans', 'Helvetica Neue', 'Helvetica', 'Arial', 'sans-serif'],
      },
      fontSize: {
        base: '14px',
      },
      spacing: {
        // 8px base spacing unit
        unit: '8px',
      },
      maxWidth: {
        container: '1200px',
      },
      boxShadow: {
        sm: '0 1px 3px rgba(0, 0, 0, 0.12)',
        md: '0 4px 6px rgba(0, 0, 0, 0.1)',
        lg: '0 10px 15px rgba(0, 0, 0, 0.1)',
      },
      borderRadius: {
        DEFAULT: '4px',
      },
    },
  },
  plugins: [
    require('@tailwindcss/forms'),
    require('@tailwindcss/typography'),
  ],
};
\`\`\`

### Using Tailwind Design Tokens

Apply Tailwind classes using the configured theme:

\`\`\`vue
<template>
  <!-- Primary button using brand colors -->
  <button class="bg-primary hover:bg-primary-600 text-white px-4 py-2 rounded">
    Click Me
  </button>

  <!-- Success state -->
  <div class="bg-success/10 border border-success text-success-700 px-4 py-3 rounded">
    Success message
  </div>

  <!-- Card with shadow -->
  <div class="bg-white shadow-md rounded p-6 max-w-container mx-auto">
    Card content
  </div>
</template>
\`\`\`

### Custom Component Classes

For complex, repeated patterns, use `@apply` in component styles:

\`\`\`vue
<style scoped>
.btn-primary {
  @apply bg-primary hover:bg-primary-600 text-white font-medium py-2 px-4 rounded transition-colors;
}

.card {
  @apply bg-white shadow-md rounded-lg p-6 border border-gray-200;
}
</style>
\`\`\`

### Common Tailwind Patterns for Beautiful UIs

#### Buttons
\`\`\`vue
<!-- Primary Button -->
<button class="bg-primary hover:bg-primary-600 active:bg-primary-700 text-white font-medium py-2 px-4 rounded-lg transition-colors shadow-sm hover:shadow-md">
  Primary Action
</button>

<!-- Secondary Button -->
<button class="bg-white hover:bg-gray-50 text-gray-700 font-medium py-2 px-4 rounded-lg border border-gray-300 transition-colors">
  Secondary Action
</button>

<!-- Danger Button -->
<button class="bg-error hover:bg-red-700 text-white font-medium py-2 px-4 rounded-lg transition-colors">
  Delete
</button>

<!-- Icon Button -->
<button class="p-2 hover:bg-gray-100 rounded-lg transition-colors">
  <Settings class="w-5 h-5 text-gray-600" />
</button>
\`\`\`

#### Cards and Containers
\`\`\`vue
<!-- Basic Card -->
<div class="bg-white rounded-lg shadow-md p-6 border border-gray-200">
  <h3 class="text-lg font-semibold text-gray-900 mb-2">Card Title</h3>
  <p class="text-gray-600">Card content goes here</p>
</div>

<!-- Interactive Card (hover effect) -->
<div class="bg-white rounded-lg shadow-md p-6 border border-gray-200 hover:shadow-lg hover:border-primary transition-all cursor-pointer">
  <h3 class="text-lg font-semibold text-gray-900 mb-2">Interactive Card</h3>
</div>

<!-- Card with Header and Footer -->
<div class="bg-white rounded-lg shadow-md overflow-hidden border border-gray-200">
  <div class="bg-gray-50 px-6 py-4 border-b border-gray-200">
    <h3 class="text-lg font-semibold text-gray-900">Header</h3>
  </div>
  <div class="p-6">
    <p class="text-gray-600">Content</p>
  </div>
  <div class="bg-gray-50 px-6 py-4 border-t border-gray-200 flex justify-end gap-3">
    <button class="px-4 py-2 text-gray-700 hover:bg-gray-200 rounded transition-colors">Cancel</button>
    <button class="px-4 py-2 bg-primary text-white rounded hover:bg-primary-600 transition-colors">Save</button>
  </div>
</div>
\`\`\`

#### Form Inputs
\`\`\`vue
<!-- Text Input -->
<input
  type="text"
  class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary focus:border-primary outline-none transition-all"
  placeholder="Enter text..."
/>

<!-- Input with Icon -->
<div class="relative">
  <Search class="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-400" />
  <input
    type="text"
    class="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary focus:border-primary outline-none"
    placeholder="Search..."
  />
</div>

<!-- Input with Error State -->
<div>
  <input
    type="email"
    class="w-full px-4 py-2 border border-error rounded-lg focus:ring-2 focus:ring-error outline-none"
    placeholder="Email"
  />
  <p class="mt-1 text-sm text-error">Please enter a valid email address</p>
</div>

<!-- Select Dropdown -->
<select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary focus:border-primary outline-none bg-white">
  <option>Select an option</option>
  <option>Option 1</option>
  <option>Option 2</option>
</select>
\`\`\`

#### Alerts and Notifications
\`\`\`vue
<!-- Success Alert -->
<div class="bg-success/10 border border-success rounded-lg p-4 flex items-start gap-3">
  <CheckCircle2 class="w-5 h-5 text-success flex-shrink-0 mt-0.5" />
  <div>
    <h4 class="font-semibold text-success-700 mb-1">Success!</h4>
    <p class="text-sm text-success-700">Your changes have been saved successfully.</p>
  </div>
</div>

<!-- Error Alert -->
<div class="bg-error/10 border border-error rounded-lg p-4 flex items-start gap-3">
  <AlertCircle class="w-5 h-5 text-error flex-shrink-0 mt-0.5" />
  <div>
    <h4 class="font-semibold text-red-900 mb-1">Error</h4>
    <p class="text-sm text-red-800">Something went wrong. Please try again.</p>
  </div>
</div>

<!-- Warning Alert -->
<div class="bg-warning/10 border border-warning rounded-lg p-4 flex items-start gap-3">
  <AlertTriangle class="w-5 h-5 text-warning flex-shrink-0 mt-0.5" />
  <div>
    <h4 class="font-semibold text-orange-900 mb-1">Warning</h4>
    <p class="text-sm text-orange-800">This action cannot be undone.</p>
  </div>
</div>

<!-- Info Alert -->
<div class="bg-info/10 border border-info rounded-lg p-4 flex items-start gap-3">
  <Info class="w-5 h-5 text-info flex-shrink-0 mt-0.5" />
  <div>
    <h4 class="font-semibold text-indigo-900 mb-1">Information</h4>
    <p class="text-sm text-indigo-800">Here's some helpful information.</p>
  </div>
</div>
\`\`\`

#### Loading States
\`\`\`vue
<!-- Loading Spinner -->
<div class="flex items-center justify-center p-8">
  <Loader2 class="w-8 h-8 text-primary animate-spin" />
</div>

<!-- Skeleton Loader -->
<div class="animate-pulse">
  <div class="h-4 bg-gray-200 rounded w-3/4 mb-4"></div>
  <div class="h-4 bg-gray-200 rounded w-1/2 mb-4"></div>
  <div class="h-4 bg-gray-200 rounded w-5/6"></div>
</div>

<!-- Button Loading State -->
<button
  disabled
  class="bg-primary text-white font-medium py-2 px-4 rounded-lg opacity-50 cursor-not-allowed inline-flex items-center gap-2"
>
  <Loader2 class="w-4 h-4 animate-spin" />
  <span>Loading...</span>
</button>
\`\`\`

#### Badges and Tags
\`\`\`vue
<!-- Status Badges -->
<span class="inline-flex items-center gap-1 px-2.5 py-0.5 rounded-full text-xs font-medium bg-success/10 text-success border border-success">
  <CheckCircle2 class="w-3 h-3" />
  Active
</span>

<span class="inline-flex items-center gap-1 px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-700 border border-gray-300">
  <Clock class="w-3 h-3" />
  Pending
</span>

<span class="inline-flex items-center gap-1 px-2.5 py-0.5 rounded-full text-xs font-medium bg-error/10 text-error border border-error">
  <X class="w-3 h-3" />
  Inactive
</span>
\`\`\`

## Interaction Patterns

### Form Interactions
- **Inline Validation:** Real-time feedback as users type (reference design-spec copy for validation messaging)
- **Error Prevention:** Disable submit until valid, following PRD acceptance criteria
- **Clear Error Messages:** Specific, actionable error text consistent with design content guidelines
- **Progress Indication:** Multi-step form progress, aligned with design-spec progress indicators and PRD flow sequencing

### Data Loading
- **Skeleton Screens:** Show layout structure while loading; follow design-spec visuals and timing guidance
- **Progressive Loading:** Load critical content first per PRD priorities
- **Optimistic Updates:** Immediate UI feedback when actions succeed; match design-spec animations
- **Error Recovery:** Clear retry mechanisms using prescribed copy and button placements

### Navigation
- **Breadcrumbs:** Clear location indication matching design hierarchy
- **Tab Navigation:** For related content sections; replicate tab behaviour defined in design spec
- **Pagination:** For large data sets, using design-spec controls and PRD limits
- **Search:** Global and contextual search; include filtering rules and debounce requirements from PRD

## Accessibility Requirements

### WCAG 2.1 AA Compliance
- **Color Contrast:** Minimum 4.5:1 for normal text, 3:1 for large text
- **Keyboard Navigation:** All interactive elements keyboard accessible
- **Focus Indicators:** Clear visual focus states
- **Screen Reader Support:** Proper ARIA labels and landmarks

### Implementation Guidelines
\`\`\`vue
<!-- Example accessible component structure -->
<template>
  <nav role="navigation" aria-label="Main navigation">
    <ul role="list">
      <li v-for="item in navItems" :key="item.id">
        <a
          :href="item.url"
          :aria-current="item.active ? 'page' : null"
          @click="handleNavigation"
        >
          {{ item.label }}
        </a>
      </li>
    </ul>
  </nav>
</template>
\`\`\`

### Testing Requirements
- **Keyboard Testing:** Navigate entire app without mouse
- **Screen Reader Testing:** NVDA/JAWS on Windows, VoiceOver on Mac
- **Color Contrast:** Automated testing with axe-core
- **Focus Management:** Proper focus restoration after modals

## Performance Optimization

### Loading Strategy
- **Code Splitting:** Lazy load route components
- **Image Optimization:** Responsive images with loading="lazy"
- **Font Loading:** FOUT prevention with font-display
- **CSS Optimization:** Critical CSS inline, rest async

### Runtime Performance
- **Virtual Scrolling:** For large lists
- **Debounced Inputs:** Prevent excessive API calls
- **Memoization:** Cache expensive computations
- **Animation Performance:** CSS transforms over position

## Error Handling & Feedback

### Error States
- **Network Errors:** Clear offline indication
- **Validation Errors:** Inline field-level messages
- **System Errors:** User-friendly error pages
- **Permission Errors:** Clear access denied messaging

### User Feedback
- **Success Confirmations:** Clear success messages
- **Progress Indicators:** Long-running operations
- **Undo Actions:** Where appropriate
- **Help Text:** Contextual assistance

## Integration with Middleware

### State Management Integration
\`\`\`javascript
// Example Vue.js 3.5.13 integration with middleware
export default {
  data() {
    return {
      workflowState: null,
      loading: false,
      error: null
    };
  },

  async created() {
    try {
      this.loading = true;
      // Get current state from middleware
      // Replace [WidgetName] with actual widget global namespace
      this.workflowState = await window.[WidgetName]
        .middleware
        .stateManager
        .getWorkflowState('[workflow-name]');
    } catch (error) {
      this.error = window.[WidgetName]
        .middleware
        .errorHandler
        .getUserMessage(error);
    } finally {
      this.loading = false;
    }
  }
};
\`\`\`

### Event System Integration
\`\`\`javascript
// Listen for middleware events in Vue 3.5.13
mounted() {
  // Replace [WidgetName] with actual widget global namespace
  window.[WidgetName].middleware.on('workflow:updated', this.handleWorkflowUpdate);
  window.[WidgetName].middleware.on('error:occurred', this.handleError);
},

// Vue 2 lifecycle hook
beforeDestroy() {
  window.[WidgetName].middleware.off('workflow:updated', this.handleWorkflowUpdate);
  window.[WidgetName].middleware.off('error:occurred', this.handleError);
}
\`\`\`

## Implementation Guidelines

### Package Dependencies Setup

**Required NPM Packages:**

Add these dependencies to `package.json`:

\`\`\`json
{
  "dependencies": {
    "vue": "^3.5.13",
    "lucide-vue-next": "^0.x.x",
    "core-js": "^3.39.0",
    "regenerator-runtime": "^0.14.1"
  },
  "devDependencies": {
    "tailwindcss": "^3.x.x",
    "postcss": "^8.x.x",
    "autoprefixer": "^10.x.x",
    "@tailwindcss/forms": "^0.5.x",
    "@tailwindcss/typography": "^0.5.x",
    "gulp": "^5.0.0",
    "gulp-sass": "^5.1.0",
    "sass": "^1.81.0",
    "webpack": "^5.96.1",
    "vue-loader": "^17.4.2",
    "@babel/core": "^7.26.0",
    "@babel/preset-env": "^7.26.0"
  }
}
\`\`\`

**Build Configuration:**

1. **Tailwind Config** (`tailwind.config.js`):
   - Configure content paths to scan for classes
   - Extend theme with Fliplet brand colors
   - Add required plugins

2. **PostCSS Config** (`postcss.config.js`):
   - Configure Tailwind processing
   - Add autoprefixer for browser compatibility

3. **Gulp/Webpack Build**:
   - Compile Tailwind CSS into `dist/css/index.css`
   - Bundle Vue components into `dist/app.js`
   - Ensure production builds purge unused CSS

### Fliplet Widget File Loading & Dependencies

**CRITICAL:** All CSS and JavaScript files must be properly declared in `widget.json` to be loaded by Fliplet. Files cannot be loaded independently - they must follow Fliplet's asset management system.

#### Widget.json Configuration

Every UI component file must be declared in `widget.json` under the appropriate context:

\`\`\`json
{
  "name": "Widget Name",
  "build": {
    "dependencies": [
      "fliplet-core"
    ],
    "assets": [
      "dist/css/index.css",
      "dist/app.js"
    ]
  },
  "interface": {
    "dependencies": [
      "fliplet-core"
    ],
    "assets": [
      "dist/css/interface.css",
      "dist/interface.js"
    ]
  }
}
\`\`\`

**Note:** With Tailwind CSS and Vue compiled through Gulp/Webpack:
- All component CSS is compiled into `dist/css/index.css` (includes Tailwind utilities)
- All component JavaScript is bundled into `dist/app.js` (includes Vue components and lucide-vue-next)
- Only the compiled/bundled files need to be declared in `widget.json`

#### Dependency Requirements

**Available Dependencies:** All dependencies must be available in [Fliplet's asset library](https://api.fliplet.com/v1/widgets/assets). Check the API endpoint before specifying any dependency.

**Context-Specific Loading:**
- **Build Context:** Files loaded in the published app for end users
- **Interface Context:** Files loaded in Fliplet Studio for configuration

#### File Organization Strategy

\`\`\`
/css/
├── build.css          # Compiled styles for end users
├── interface.css      # Compiled styles for Studio
└── components/        # Individual component styles (pre-build)
    ├── layout/
    ├── forms/
    └── ui/

/js/
├── build.js           # Main entry point for end users
├── interface.js       # Main entry point for Studio
└── components/        # Individual components
    ├── layout/
    │   ├── app-shell.js
    │   └── navigation-header.js
    ├── pages/
    │   └── dashboard-view.js
    ├── forms/
    │   └── settings-form.js
    └── ui/
        ├── data-table.js
        └── status-indicator.js
\`\`\`

#### HTML Template Integration

**Build Context Templates:** Must be in `build.html` or loaded via JavaScript:
\`\`\`html
<!-- build.html -->
<div id="app">
  <!-- Component templates go here -->
</div>

<!-- OR loaded dynamically -->
<script>
window.[WidgetName].templates = {
  'app-shell': '<div class="app-shell">...</div>',
  'data-table': '<table class="data-table">...</table>'
};
</script>
\`\`\`

**Interface Context Templates:** Must be in `interface.html` or loaded via JavaScript:
\`\`\`html
<!-- interface.html -->
<div class="widget-settings">
  <!-- Configuration UI templates -->
</div>
\`\`\`

#### Asset Loading Order

Files are loaded in the exact order listed in the `assets` array:

\`\`\`json
{
  "build": {
    "assets": [
      "css/base.css",           // 1. Base styles first
      "css/components.css",     // 2. Component styles
      "css/themes.css",         // 3. Theme overrides
      "js/utils.js",           // 4. Utilities first
      "js/components/base.js",  // 5. Base components
      "js/components/ui.js",    // 6. UI components
      "js/main.js"             // 7. Main application last
    ]
  }
}
\`\`\`

#### Build Optimization Options

**Option 1: Manual Compilation**
Use build tools (gulp, webpack) to compile multiple files:

\`\`\`json
{
  "build": {
    "assets": [
      "dist/app.min.css",    # Single compiled CSS
      "dist/app.min.js"      # Single compiled JS
    ]
  }
}
\`\`\`

**Option 2: Fliplet Auto-Concatenation**
List individual files - Fliplet automatically concatenates in production:

\`\`\`json
{
  "build": {
    "assets": [
      "css/base.css",
      "css/layout.css",
      "css/forms.css",
      "css/ui.css",
      "js/utils.js",
      "js/components.js",
      "js/main.js"
    ]
  }
}
\`\`\`

#### Vue.js 3.5.13 Component Loading

**Component Registration Pattern:**
\`\`\`javascript
// Each component file should register itself globally
(function() {
  'use strict';

  // Replace [WidgetName] with actual widget namespace
  window.[WidgetName] = window.[WidgetName] || {};
  window.[WidgetName].components = window.[WidgetName].components || {};

  // Register component
  window.[WidgetName].components['AppShell'] = {
    template: window.[WidgetName].templates['app-shell'],
    props: ['branding', 'navigation'],
    data() {
      return {
        // component state
      };
    },
    methods: {
      // component methods
    }
  };
})();
\`\`\`

**Main Application Registration:**
\`\`\`javascript
// main.js - loaded last in assets array
(function() {
  'use strict';

  // Create Vue app with all registered components
  window.[WidgetName].app = new Vue({
    el: '#app',
    components: window.[WidgetName].components,
    data: {
      // app state
    }
  });
})();
\`\`\`

#### Critical Implementation Checklist

Before generating UI implementation tasks, verify:

1. **✅ Context Clarity:** Confirmed whether building for interface or build context
2. **✅ Dependency Check:** All dependencies exist in [Fliplet's asset library](https://api.fliplet.com/v1/widgets/assets)
3. **✅ File Declaration:** Every CSS/JS file listed in appropriate widget.json context
4. **✅ Load Order:** Assets listed in correct loading sequence
5. **✅ Template Strategy:** HTML templates integrated via build.html/interface.html or JavaScript
6. **✅ Component Registration:** Vue components properly registered in global namespace
7. **✅ Build Strategy:** Chosen between manual compilation vs Fliplet auto-concatenation

#### Example Implementation Reference

See [fliplet-widget-form-builder](https://github.com/Fliplet/fliplet-widget-form-builder/blob/master/widget.json) and [fliplet-widget-theme](https://github.com/Fliplet/fliplet-widget-theme/blob/master/widget.json) for complete examples of proper asset declaration and loading.

## Component Documentation

### Component Template

Example component using Tailwind CSS and lucide-vue-next icons:

\`\`\`vue
<template>
  <div
    class="bg-white rounded-lg shadow-md p-6 transition-all duration-200"
    :class="{
      'border-2 border-primary': isActive,
      'border border-error': hasError
    }"
  >
    <!-- Component header with icon -->
    <div class="flex items-center gap-3 mb-4">
      <CheckCircle2
        v-if="isSuccess"
        class="w-5 h-5 text-success"
        :stroke-width="2"
      />
      <AlertCircle
        v-else-if="hasError"
        class="w-5 h-5 text-error"
        :stroke-width="2"
      />

      <h3 class="text-lg font-semibold text-gray-900">
        {{ title }}
      </h3>
    </div>

    <!-- Component content -->
    <div class="text-sm text-gray-600">
      <slot />
    </div>

    <!-- Action button -->
    <button
      v-if="showAction"
      @click="handleAction"
      class="mt-4 bg-primary hover:bg-primary-600 text-white font-medium py-2 px-4 rounded transition-colors inline-flex items-center gap-2"
      :disabled="isLoading"
    >
      <Loader2
        v-if="isLoading"
        class="w-4 h-4 animate-spin"
      />
      <span>{{ actionLabel }}</span>
    </button>
  </div>
</template>

<script>
import { CheckCircle2, AlertCircle, Loader2 } from 'lucide-vue-next';

/**
 * ComponentName - Brief description
 * Vue 3.5.13 component using Options API with Tailwind CSS
 *
 * @example
 * <ComponentName
 *   title="Example Title"
 *   :is-active="true"
 *   @action="handleAction"
 * >
 *   Content goes here
 * </ComponentName>
 */
export default {
  name: 'ComponentName',

  components: {
    CheckCircle2,
    AlertCircle,
    Loader2
  },

  props: {
    /**
     * Component title
     * @type {String}
     * @required
     */
    title: {
      type: String,
      required: true
    },

    /**
     * Whether component is in active state
     * @type {Boolean}
     */
    isActive: {
      type: Boolean,
      default: false
    },

    /**
     * Whether to show action button
     * @type {Boolean}
     */
    showAction: {
      type: Boolean,
      default: false
    },

    /**
     * Action button label
     * @type {String}
     */
    actionLabel: {
      type: String,
      default: 'Submit'
    }
  },

  // Events: action

  data() {
    return {
      isLoading: false,
      hasError: false,
      isSuccess: false
    };
  },

  methods: {
    async handleAction() {
      try {
        this.isLoading = true;
        this.hasError = false;

        // Emit action event
        this.$emit('action');

        this.isSuccess = true;
      } catch (error) {
        this.hasError = true;
        console.error('Action failed:', error);
      } finally {
        this.isLoading = false;
      }
    }
  },

  mounted() {
    // Component mounted
  },

  beforeUnmount() {
    // Cleanup before component destruction (Vue 3)
  }
};
</script>

<style scoped>
/* Use Tailwind classes in template - minimal custom CSS needed */
/* Only add custom CSS for complex animations or unique requirements */
</style>
\`\`\`

## Testing Strategy

### Component Testing
- **Unit Tests:** Test component logic in isolation
- **Integration Tests:** Test component with middleware
- **Visual Tests:** Screenshot comparisons
- **Accessibility Tests:** Automated a11y testing

### User Testing
- **Usability Testing:** Task-based user testing
- **A/B Testing:** Test different UI variations
- **Performance Testing:** Load time metrics
- **Device Testing:** Cross-device compatibility

## QA Test Plan Generation

The UI/UX plan should provide sufficient detail for generating a comprehensive Test Plan for QA verification. This Test Plan will be generated as a separate task and file (`test-plan-[project-name].md`) based on the UI specifications.

### Test Plan Requirements

The UI plan must include enough detail for QA to verify:

#### Functional Testing Areas
- **State Verification:** Each UI state defined in the State-Oriented UX Specs
- **User Flow Testing:** Complete user journeys from entry to completion
- **Form Validation:** All validation rules and error messages
- **Data Display:** Correct data rendering and formatting
- **Interactive Elements:** Button behavior, navigation, and user controls
- **Permission Testing:** Role-based access and feature flag verification

#### Cross-Platform Testing Scope
- **Responsive Behavior:** Mobile, tablet, desktop breakpoint testing
- **Browser Compatibility:** Testing matrix for supported browsers
- **Device Testing:** Touch interactions, keyboard navigation
- **Accessibility Testing:** Screen reader compatibility, keyboard navigation

#### Edge Case Testing Scenarios
- **Empty States:** No data available scenarios
- **Error States:** Network failures, API errors, validation failures
- **Loading States:** Long-running operations, timeout handling
- **Permission States:** Unauthorized access, insufficient privileges
- **Offline Scenarios:** Network connectivity issues

#### Performance Testing Benchmarks
- **Load Time Targets:** Based on performance optimization requirements
- **User Interaction Response:** Click-to-feedback timing requirements
- **Memory Usage:** Resource consumption limits
- **Network Usage:** Data transfer optimization verification

### Test Plan Generation Process

1. **Extract Testable Requirements:** From UI states, user flows, and component specifications
2. **Map Test Scenarios:** Each state transition and user action becomes a test case
3. **Define Success Criteria:** Measurable outcomes for each test scenario
4. **Create Test Data Requirements:** Mock data, user accounts, and system states needed
5. **Document Expected Behaviors:** Precise descriptions of correct system responses

## Implementation Priorities

### Phase 1: Core Components
1. AppShell and navigation
2. Basic form components
3. Data display components
4. Error handling components

### Phase 2: Advanced Features
1. Complex workflows
2. Data visualization
3. Advanced filtering
4. Batch operations

### Phase 3: Polish & Optimization
1. Animation refinements
2. Performance optimization
3. Advanced theming
4. Enhanced accessibility

## Success Metrics

### User Experience Metrics
- **Task Completion Rate:** 95%+ successful completions
- **Time to Complete:** Reduced by 30% from current
- **Error Rate:** Less than 5% user errors
- **Satisfaction Score:** 4.5+ out of 5

### Technical Metrics
- **Load Time:** Initial load under 3 seconds
- **Accessibility Score:** 100% WCAG 2.1 AA compliance
- **Browser Support:** Modern browsers + IE11
- **Device Support:** Responsive from 320px width

### Design System Metrics
- **Component Reuse:** 80%+ shared components
- **Theme Adoption:** Easy customization demonstrated
- **Documentation Coverage:** 100% components documented
- **Design Consistency:** Style guide adherence

## File Structure Plan

\`\`\`
/
├── src/
│   ├── components/
│   │   ├── layout/
│   │   │   ├── AppShell.vue
│   │   │   ├── NavigationHeader.vue
│   │   │   ├── PageContainer.vue
│   │   │   └── FooterSection.vue
│   │   ├── pages/
│   │   │   ├── [PageName]View.vue
│   │   │   └── ...
│   │   ├── forms/
│   │   │   ├── [FormName]Form.vue
│   │   │   ├── FormField.vue
│   │   │   └── ValidationMessage.vue
│   │   ├── ui/
│   │   │   ├── DataTable.vue
│   │   │   ├── StatusIndicator.vue
│   │   │   ├── ActionButton.vue
│   │   │   └── LoadingSpinner.vue
│   │   ├── feedback/
│   │   │   ├── NotificationToast.vue
│   │   │   ├── ModalDialog.vue
│   │   │   └── ErrorBoundary.vue
│   │   └── shared/
│   │       ├── BaseComponent.vue
│   │       └── TransitionWrapper.vue
│   ├── scss/
│   │   └── index.scss              # Tailwind directives and custom styles
│   ├── utils/
│   │   ├── validators.js
│   │   ├── formatters.js
│   │   └── accessibility.js
│   ├── Application.vue             # Root Vue component
│   └── main.js                     # Vue app initialization
├── dist/
│   ├── css/
│   │   └── index.css               # Compiled Tailwind + custom CSS
│   └── app.js                      # Bundled Vue app + components
├── build.html                      # Widget HTML template (build context)
├── interface.html                  # Widget HTML template (interface context)
├── tailwind.config.js              # Tailwind theme configuration
├── postcss.config.js               # PostCSS configuration
├── gulpfile.js                     # Gulp build tasks
├── package.json                    # NPM dependencies
└── widget.json                     # Fliplet widget configuration
\`\`\`

**Key Files:**

- **`src/scss/index.scss`** - Main SCSS file with Tailwind directives:
  \`\`\`scss
  @tailwind base;
  @tailwind components;
  @tailwind utilities;

  // Custom component classes (use @apply sparingly)
  // Additional custom styles as needed
  \`\`\`

- **`tailwind.config.js`** - Tailwind configuration with Fliplet brand tokens
- **`dist/css/index.css`** - Compiled output (referenced in widget.json)
- **`dist/app.js`** - Bundled Vue app (referenced in widget.json)

## Next Steps

This UI/UX plan should be reviewed for:
1. **User Experience:** Intuitive workflows and clear interactions
2. **Visual Design:** Consistent with Fliplet brand guidelines
3. **Technical Feasibility:** Vue.js 3.5.13 implementation approach
4. **Accessibility:** WCAG 2.1 AA compliance throughout
5. **Performance:** Optimal loading and runtime performance

Once approved, this plan will be converted to implementation tasks using `generate-tasks.mdc`.
```

## Plan Generation Guidelines

### Comprehensive Analysis
- Read the complete middleware architecture plan
- Understand all user workflows and data flows
- Identify every user interaction point
- Map all states (loading, error, success, empty)

### UI/UX Design
- **Design beautiful, production-worthy interfaces** - not cookie-cutter templates
- **Use Tailwind CSS exclusively** for all styling (no custom CSS frameworks)
- **Use lucide-vue-next** for all icons (no other icon libraries unless absolutely necessary)
- Design for non-technical users first
- Ensure responsive mobile-first approach
- Plan for accessibility from the start
- Focus on visual excellence and user delight

### Documentation Quality
- Use clear, non-technical language where possible
- Include visual examples and code snippets
- Ensure compatibility with task generation
- Provide implementation guidance

### Review Considerations
- Design decisions should be clear to non-developers
- Customization options should be well-documented
- Accessibility requirements must be specific
- Performance targets should be measurable

## Target Audience

The generated plan should be suitable for:
- **Product Managers** reviewing user experience decisions
- **Designers** understanding component structure and theming
- **Developers** who will implement the components
- **QA Engineers** understanding UI behavior and states
- **Stakeholders** reviewing brand compliance

## Final Instructions

1. **Design Philosophy** - Create beautiful, production-worthy interfaces, not cookie-cutter designs
2. **Check widget context** - Clarify if building for interface or build context
3. **Review Fliplet documentation** - Use the reference table to understand constraints
4. **Analyze the middleware architecture** thoroughly before beginning
5. **Use Tailwind CSS exclusively** - All styling must use Tailwind utility classes
6. **Use lucide-vue-next for icons** - Do not use other icon libraries unless absolutely necessary
7. **Design for Vue.js 3.5.13** - Use Options API for compatibility
8. **Configure Tailwind theme** - Extend with Fliplet brand colors, spacing, and design tokens
9. **Plan NPM dependencies** - List all required packages in package.json (Tailwind, lucide-vue-next, etc.)
10. **Plan build process** - Ensure Tailwind compilation through Gulp/Webpack into dist/ folder
11. **Create a complete UI/UX plan** that addresses every user touchpoint
12. **Ensure the plan structure** matches the required format exactly
13. **Use generic naming** - Replace [WidgetName], [project-name] with actual values
14. **Include specific details** that can be converted to actionable tasks
15. **Plan for accessibility** and responsive design throughout (WCAG 2.1 AA)
16. **Focus on visual excellence** - Attention to spacing, typography, colors, and interactions
17. **Consider non-technical reviewers** in your language choices
18. **Prepare for task generation** by including implementation details
19. **Follow implementation guidelines** - Only compiled files (dist/) declared in widget.json
20. **Fliplet dependencies** - Only fliplet-core is required; avoid fliplet-studio-ui, bootstrap-css
