---
description: Generating UI-Agnostic Client-Side Middleware from REST API Documentation
globs:
alwaysApply: false
---
# Rule: Generating UI-Agnostic Client-Side Middleware from REST API Documentation

## Goal

To guide an AI assistant in creating a comprehensive, UI-agnostic client-side middleware system using vanilla JavaScript (without ES Modules or CommonJS) that enforces workflows, manages application state, handles API interactions, and ensures data integrity based on REST API documentation.

## Output

- **Format:** Vanilla JavaScript (`.js`)
- **Location:** `/src/middleware/` (depending on project structure)
- **Structure:** Multiple interconnected class files that work together
- **Module System:** None - uses global namespace and dependency injection patterns

## Core Principles

1. **Workflow Enforcement:** Prevent users from skipping required steps or attempting actions without proper dependencies
2. **Data Integrity:** Ensure all required data is collected before proceeding with operations
3. **State Management:** Centralized application state with validation and change tracking
4. **Error Handling:** Comprehensive error handling with user-friendly messages and recovery strategies
5. **API Abstraction:** Clean wrapper services for all REST API interactions
6. **Documentation Integration:** Self-documenting code that mirrors API documentation structure
7. **Dependency Management:** Clear dependency chains and validation requirements

## Preflight & Environment Detection

Before generating code, perform these checks and align behavior accordingly:

- Detect project structure and base path for output (default `/src/middleware/`). Create missing folders as needed.
- Detect existing test framework and conventions:
  - Look for `jest.config.*`, `vitest.config.*`, `tests/setup.*`, `__tests__/`, `tests/`, and `*.test.*` files, plus a `test` script in `package.json`.
  - If found, adopt existing conventions (file placement, setup files, scripts).
  - If not found, ask the user whether to bootstrap a minimal Jest setup now. Proceed only on confirmation.
- Confirm availability of the Fliplet runtime context. All HTTP must use `Fliplet.API.request()` and respect `Fliplet.Navigate.query` overrides.

## Process

1. **Analyze API Documentation:** Read and analyze the provided REST API documentation files
2. **Identify Workflows:** Extract the sequential workflows and dependencies from API flow documentation
3. **Map Data Structures:** Identify all request/response formats and validation requirements
4. **Design State Model:** Create a state management structure that tracks workflow progress
5. **Generate Core Classes:** Create the foundational middleware classes
6. **Generate API Services:** Create specific API wrapper classes for each endpoint group
7. **Generate Workflow Controllers:** Create orchestration classes that manage multi-step processes
8. **Generate Validation Framework:** Create data validation and integrity checking systems
9. **Generate Error Handling:** Create comprehensive error handling and recovery mechanisms

10. **Testing Scaffold Handling:**
    - If a test framework exists, generate unit tests alongside each class and integration tests for key workflows using the existing conventions.
    - If no framework exists, ask the user for permission to bootstrap a minimal Jest setup (see Testing Integration). If approved, add config, setup, scripts, and a sample test, then generate class tests.

11. **Post-Generation Verification (Optional):** Ask the user whether to run tests now. If yes, run the test suite and report results. If no, skip.

## Class Structure Architecture

### 1. Core Foundation Classes

#### `BaseMiddleware` (Core Foundation)
```javascript
/**
 * Base class providing common functionality for all middleware components
 * Handles logging, error management, and event dispatching
 */
function BaseMiddleware() {
    this.events = {};
    this.config = {};
    this.logger = null;
}
```

#### `StateManager` (State Management)
```javascript
/**
 * Centralized state management with validation and change tracking
 * Enforces state transitions and dependency requirements
 */
function StateManager() {
    this.state = {};
    this.validators = {};
    this.dependencies = {};
    this.changeListeners = [];
}
```

#### `ValidationEngine` (Data Integrity)
```javascript
/**
 * Handles all data validation, field requirements, and business rules
 * Integrated with API documentation requirements
 */
function ValidationEngine() {
    this.rules = {};
    this.errorMessages = {};
    this.customValidators = {};
}
```

### 2. API Service Classes

#### `ApiClient` (HTTP Communication)
```javascript
/**
 * Core HTTP client with authentication, retry logic, and error handling
 * Handles all low-level API communication
 */
function ApiClient(baseUrl, options) {
    this.baseUrl = baseUrl;
    this.defaultHeaders = {};
    this.interceptors = {};
    this.retryConfig = {};
}
```

##### Fliplet API Integration Requirements

- All requests MUST use `Fliplet.API.request()`.
- When present, apply URL and auth overrides from `Fliplet.Navigate.query`:
  - If `Fliplet.Navigate.query.apiUrl` exists, pass `{ apiUrl }` in the request options.
  - If `Fliplet.Navigate.query.auth_token` exists, pass `{ headers: { 'Auth-token': auth_token } }`.
- Centralize this logic inside `ApiClient` so all domain services inherit consistent behavior.
- Implement consistent error mapping to internal error types using the Error Handling standards.

#### `[Domain]ApiService` (Specific API Groups)
```javascript
/**
 * Generated for each API domain (e.g., PublishingApiService, AuthApiService)
 * Maps directly to API documentation endpoints
 */
function PublishingApiService(apiClient) {
    this.client = apiClient;
    this.endpoints = {};
    this.schemas = {};
}
```

### 3. Workflow Orchestration Classes

#### `WorkflowManager` (Process Orchestration)
```javascript
/**
 * Manages multi-step workflows with dependency checking and progress tracking
 * Enforces sequential execution and validates prerequisites
 */
function WorkflowManager(stateManager, validationEngine) {
    this.stateManager = stateManager;
    this.validationEngine = validationEngine;
    this.workflows = {};
    this.currentWorkflow = null;
}
```

#### `[Process]Controller` (Specific Workflows)
```javascript
/**
 * Generated for each major workflow (e.g., PublishingController, AuthController)
 * Implements the specific business logic and step sequencing
 */
function PublishingController(apiService, stateManager, workflowManager) {
    this.apiService = apiService;
    this.stateManager = stateManager;
    this.workflowManager = workflowManager;
    this.steps = [];
}
```

### 4. Supporting Infrastructure Classes

#### `ErrorHandler` (Error Management)
```javascript
/**
 * Centralized error handling with categorization and recovery strategies
 * Maps API errors to user-friendly messages and suggested actions
 */
function ErrorHandler() {
    this.errorCatalog = {};
    this.recoveryStrategies = {};
    this.userMessageTemplates = {};
}
```

#### `DataMapper` (Data Transformation)
```javascript
/**
 * Handles data transformation between API formats and internal models
 * Ensures data consistency and type safety
 */
function DataMapper() {
    this.transformers = {};
    this.schemas = {};
    this.typeConverters = {};
}
```

## Generation Rules

### 1. API Service Generation
- Create one service class per logical API group (based on documentation sections)
- Each method corresponds to an API endpoint with full parameter validation
- Include all request/response schemas from documentation
- Implement retry logic for idempotent operations
- Add comprehensive error handling with specific error codes

### 2. Workflow Controller Generation
- Analyze API flow documentation to identify multi-step processes
- Create controller classes that enforce step sequencing
- Implement dependency checking before each step
- Add progress tracking and state persistence
- Include rollback capabilities for failed operations

### 3. State Model Generation
- Extract all data entities from API documentation
- Create state schema with validation rules
- Implement state transition validation
- Add change tracking and audit trails
- Include data persistence capabilities

### 4. Validation Rule Generation
- Extract all field requirements from API documentation
- Create validation rules for each data type
- Implement cross-field validation logic
- Add business rule validation
- Generate user-friendly error messages

### 5. Error Handling Generation
- Map all API error codes to user-friendly messages
- Create error recovery strategies
- Implement retry logic with exponential backoff
- Add error reporting and logging
- Include offline handling capabilities

## Code Standards

### Naming Conventions
- Classes: `PascalCase` (e.g., `PublishingController`)
- Methods: `camelCase` (e.g., `initializePublishing`)
- Constants: `UPPER_SNAKE_CASE` (e.g., `API_TIMEOUT`)
- Private methods: prefix with `_` (e.g., `_validateInput`)

### Documentation Standards
```javascript
/**
 * [Method Description - mirrors API documentation]
 *
 * @param {Object} params - Parameter object
 * @param {string} params.platform - Platform type (android/ios)
 * @param {string} params.type - Store type (always "appStore")
 * @param {string} [params.teamId] - Team ID (required for iOS only)
 *
 * @returns {Promise<Object>} Response object containing submission data
 *
 * @throws {ValidationError} When required parameters are missing
 * @throws {ApiError} When API call fails
 *
 * @example
 * const result = await publishingController.initializePublishing({
 *   platform: 'ios',
 *   type: 'appStore',
 *   teamId: 'AFIG8RX79F'
 * });
 */
```

### Error Handling Standards
```javascript
// Standardized error object structure
{
  code: 'VALIDATION_ERROR',
  message: 'User-friendly error message',
  details: {
    field: 'platform',
    expected: 'android or ios',
    received: 'invalid_value'
  },
  recoverable: true,
  suggestedAction: 'Please select a valid platform',
  timestamp: new Date().toISOString()
}
```

### State Management Standards
```javascript
// Standardized state structure
{
  workflows: {
    publishing: {
      currentStep: 'initialize',
      progress: 0.2,
      data: {},
      errors: [],
      isComplete: false,
      dependencies: ['auth', 'apiKeys']
    }
  },
  cache: {},
  user: {},
  config: {}
}
```

## Integration Patterns

### Dependency Injection
```javascript
// Initialize middleware system
function initializeMiddleware(config) {
  const stateManager = new StateManager();
  const validationEngine = new ValidationEngine();
  const errorHandler = new ErrorHandler();
  const apiClient = new ApiClient(config.apiBaseUrl, config.apiOptions);

  // Inject dependencies
  const publishingApi = new PublishingApiService(apiClient);
  const publishingController = new PublishingController(
    publishingApi,
    stateManager,
    new WorkflowManager(stateManager, validationEngine)
  );

  return {
    publishing: publishingController,
    state: stateManager,
    validation: validationEngine,
    errors: errorHandler
  };
}
```

### Event System
```javascript
// Standardized event patterns
middleware.on('workflow.step.completed', function(event) {
  console.log('Step completed:', event.step, event.data);
});

middleware.on('validation.failed', function(event) {
  console.error('Validation failed:', event.errors);
});

middleware.on('api.error', function(event) {
  console.error('API error:', event.error, event.context);
});
```

## Output Structure

Generate the following file structure:

```
/src/middleware/
├── core/
│   ├── BaseMiddleware.js
│   ├── StateManager.js
│   ├── ValidationEngine.js
│   ├── ErrorHandler.js
│   └── DataMapper.js
├── api/
│   ├── ApiClient.js
│   ├── PublishingApiService.js
│   ├── AuthApiService.js
│   └── FileApiService.js
├── controllers/
│   ├── WorkflowManager.js
│   ├── PublishingController.js
│   ├── AuthController.js
│   └── FileUploadController.js
├── config/
│   ├── endpoints.js
│   ├── validation-rules.js
│   ├── error-messages.js
│   └── workflows.js
└── middleware.js (main initialization file)
```

## Testing Integration

Each generated class should include:
- Unit test file (`[ClassName].test.js`)
- Integration test scenarios
- Mock data for testing
- Error simulation capabilities

Framework detection and bootstrapping:

- Detection: If `jest.config.*`, `vitest.config.*`, a `tests/` directory, or a `test` script in `package.json` exists, follow those conventions for file placement and setup.
- Bootstrapping (only with user confirmation): If no framework exists, generate a minimal Jest setup:
  - Add `jest.config.js` configured for vanilla JS and the project structure
  - Add `tests/setup.js` to stub globals (e.g., a minimal `global.Fliplet` with `API.request` and `Navigate.query`)
  - Add npm scripts to `package.json`: `"test"`, `"test:watch"`, `"test:coverage"`
  - Add a simple `example.test.js` to verify the setup executes correctly
  - Co-locate `*.test.js` files next to the implementation they cover (or adopt existing test folder conventions if detected)

Running tests:

- After generation, ask the user: “Run tests now? (y/n)”. If yes, execute the test suite and report results. If no, skip.

Mocking Fliplet:

- In tests, stub `global.Fliplet` with at least `API.request` and `Navigate.query` to avoid network calls. Consider MSW or local stubs when simulating HTTP.

## UI Integration Readiness

The generated middleware should:
- Expose clear, documented public APIs
- Provide real-time state updates via events
- Include progress tracking for long-running operations
- Offer validation feedback before submission
- Support multiple UI frameworks through adapter patterns

## Target Audience

The generated middleware should be usable by:
- **Frontend developers** building UI on top of the middleware
- **Junior developers** who need clear guidance and documentation
- **UI framework integrators** who need clean APIs
- **QA engineers** who need to understand data flows and error states

## Final Instructions

1. Always start by analyzing the complete API documentation structure
2. Generate comprehensive class hierarchies that mirror the API organization
3. Ensure all workflows enforce proper sequencing and dependencies
4. Include extensive validation at every level
5. Create self-documenting code with examples
6. Build in error recovery and retry mechanisms
7. Design for testability and maintainability
8. Prepare the middleware to serve as a foundation for UI development
9. Enforce Fliplet API usage and `Fliplet.Navigate.query` handling within `ApiClient`
10. Confirm with the user before adding or running tests; when approved, ensure testing scaffolding exists or is bootstrapped
